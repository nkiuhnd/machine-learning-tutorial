<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初中生K-均值聚类学习工具</title>
    <!-- 使用本地Chart.js或备用CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // 如果Chart.js加载失败，使用备用方案
        if (typeof Chart === 'undefined') {
            console.warn('Chart.js加载失败，使用备用方案');
            // 创建一个简单的图表模拟对象
            window.Chart = function(ctx, config) {
                this.data = config.data;
                this.options = config.options;
                this.update = function() {
                    console.log('图表更新（模拟）');
                };
            };
        }
    </script>
    <script src="../js/utils.js"></script>
    
    <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
    <div class="container">
        
        <!-- 导航栏 -->
        <nav class="nav-bar">
            <ul class="nav-links">
                <li><a href="../index-modern.html">🏠 返回首页</a></li>
                <li><a href="#theory">📚 理论</a></li>
                <li><a href="#interactive">🎮 互动</a></li>
                <li><a href="#practice">💡 练习</a></li>
            </ul>
        </nav>
    
        <div class="header">
            <h1>🛒 K-均值聚类学习</h1>
            <p>把相似的商品分到同一组</p>
        </div>
        
        <div class="section">
            <h2>📊 第一步：观察商品数据</h2>
            <p>我们来看看超市里不同商品的价格和重量：</p>
            
            <table class="data-table">
                <thead>
                    <tr>
                        <th>商品</th>
                        <th>价格(元)</th>
                        <th>重量(克)</th>
                        <th>初始分组</th>
                    </tr>
                </thead>
                <tbody id="dataTable">
                    <tr><td>苹果</td><td>8</td><td>200</td><td>?</td></tr>
                    <tr><td>橙子</td><td>6</td><td>150</td><td>?</td></tr>
                    <tr><td>牛奶</td><td>15</td><td>500</td><td>?</td></tr>
                    <tr><td>面包</td><td>12</td><td>300</td><td>?</td></tr>
                    <tr><td>巧克力</td><td>25</td><td>100</td><td>?</td></tr>
                    <tr><td>薯片</td><td>18</td><td>150</td><td>?</td></tr>
                </tbody>
            </table>
        </div>
        
        <div class="section">
            <h2>🤔 思考与探索</h2>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #667eea;">
                <p><strong>什么是K-均值聚类？</strong></p>
                <p>K-均值聚类是一种把相似数据分到同一组的算法。就像超市把相似的商品放在一起：</p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li>🍎 水果区：苹果、橙子、香蕉...</li>
                    <li>🥛 奶制品区：牛奶、酸奶、奶酪...</li>
                    <li>🍫 零食区：巧克力、薯片、饼干...</li>
                </ul>
                
                <p><strong>K-均值算法的核心思想：</strong></p>
                <ol style="margin: 10px 0; padding-left: 20px;">
                    <li>🎯 先选K个"中心点"（比如3个区域）</li>
                    <li>📏 计算每个商品到各个中心的距离</li>
                    <li>🏷️ 把商品分到最近的中心</li>
                    <li>🔄 重新计算每个组的中心位置</li>
                    <li>🔄 重复直到中心不再移动</li>
                </ol>
                
                <p><strong>为什么要用聚类？</strong></p>
                <p>帮助我们发现数据中的规律，把相似的东西归类，让管理更简单！</p>
            </div>
        </div>
        
        <div class="section">
            <h2>🎮 第二步：动手实验</h2>
            <div class="controls">
                <div class="input-group">
                    <label>聚类数量 K：</label>
                    <select id="kValue">
                        <option value="2">2组</option>
                        <option value="3" selected>3组</option>
                        <option value="4">4组</option>
                    </select>
                </div>
                
                <button onclick="generateRandomData()">🎲 生成商品数据</button>
                <button onclick="initializeCentroids()">🎯 选择中心点</button>
                <button onclick="runOneStep()">⏭️ 执行一步</button>
                <button onclick="runFullClustering()">🔄 完整聚类</button>
                <button onclick="resetClustering()">🔄 重置</button>
            </div>
            
            <div class="step-indicator">
                <div class="step" id="step1" onclick="showStep(1)">1. 选择中心</div>
                <div class="step" id="step2" onclick="showStep(2)">2. 分配商品</div>
                <div class="step" id="step3" onclick="showStep(3)">3. 更新中心</div>
                <div class="step" id="step4" onclick="showStep(4)">4. 完成聚类</div>
            </div>
        </div>
        
        <div class="section">
            <h2>📈 第三步：可视化聚类过程</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>聚类1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>聚类2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #45b7d1;"></div>
                    <span>聚类3</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #96ceb4;"></div>
                    <span>聚类4</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #000; border: 2px solid #333;"></div>
                    <span>中心点</span>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="clusterChart"></canvas>
            </div>
        </div>
        
        <div class="section">
            <h2>📊 聚类结果分析</h2>
            <div class="cluster-info" id="clusterInfo">
                <div class="cluster-card cluster-0">
                    <h4>聚类1</h4>
                    <p>商品数量：<span id="count1">0</span></p>
                    <p>平均价格：<span id="avgPrice1">-</span>元</p>
                    <p>平均重量：<span id="avgWeight1">-</span>克</p>
                    <p>商品类型：<span id="type1">-</span></p>
                </div>
                <div class="cluster-card cluster-1">
                    <h4>聚类2</h4>
                    <p>商品数量：<span id="count2">0</span></p>
                    <p>平均价格：<span id="avgPrice2">-</span>元</p>
                    <p>平均重量：<span id="avgWeight2">-</span>克</p>
                    <p>商品类型：<span id="type2">-</span></p>
                </div>
                <div class="cluster-card cluster-2">
                    <h4>聚类3</h4>
                    <p>商品数量：<span id="count3">0</span></p>
                    <p>平均价格：<span id="avgPrice3">-</span>元</p>
                    <p>平均重量：<span id="avgWeight3">-</span>克</p>
                    <p>商品类型：<span id="type3">-</span></p>
                </div>
            </div>
            
            <div class="distance-info" id="distanceInfo">
                <h4>距离计算详情</h4>
                <p>点击"执行一步"查看每个步骤的距离计算</p>
            </div>
        </div>
        
        <div class="section">
            <h2>🎯 第四步：实时预测</h2>
            <div class="controls" style="flex-direction: column; align-items: stretch;">
                <div class="input-group" style="margin-bottom: 15px;">
                    <label>输入新商品数据：</label>
                    <input type="number" id="newPrice" placeholder="价格(元)" min="0" max="100" value="20">
                    <input type="number" id="newWeight" placeholder="重量(克)" min="0" max="1000" value="250">
                    <button onclick="predictCluster()">🔍 预测分组</button>
                </div>
            </div>
            
            <div class="prediction-result" id="predictionResult">
                输入商品数据，点击"预测分组"查看结果
            </div>
        </div>
        
        <div class="section">
            <h2>🤖 小结：K-均值聚类的应用</h2>
            <div style="background: #d1ecf1; padding: 15px; border-radius: 8px; border-left: 5px solid #17a2b8;">
                <h3>🧠 K-均值聚类在生活中的应用</h3>
                <p><strong>🏪 超市商品分类：</strong>把相似的商品放在一起，方便顾客购物</p>
                <p><strong>👥 客户分群：</strong>根据购买行为，把客户分为"高价值"、"潜力"、"普通"等群体</p>
                <p><strong>📱 推荐系统：</strong>把喜好相似的用户分到一组，推荐相似商品</p>
                <p><strong>🏥 医疗诊断：</strong>根据症状相似性，把病人分组进行针对性治疗</p>
                
                <h3>🎯 K-均值算法的优势</h3>
                <ol>
                    <li>🚀 计算简单快速</li>
                    <li>📊 结果直观易懂</li>
                    <li>🎯 可以处理大数据</li>
                    <li>🔧 参数少，容易调优</li>
                </ol>
                
                <h3>⚠️ 注意事项</h3>
                <ul>
                    <li>需要提前知道聚类数量K</li>
                    <li>对初始中心点敏感</li>
                    <li>适合球形分布的数据</li>
                    <li>不同特征的重要性需要平衡</li>
                </ul>
                
                <h3>💡 算法流程总结</h3>
                <p><strong>输入：</strong>数据点 + 聚类数量K</p>
                <p><strong>输出：</strong>K个聚类 + 每个聚类的中心点</p>
                <p><strong>核心：</strong>最小化每个点到其中心点的距离平方和</p>
            </div>
        </div>
    </div>

    <script>
        // K-均值聚类专用变量，避免与utils.js中的chart冲突
        let kmeansChart;
        let dataPoints = [];
        let centroids = [];
        let clusters = [];
        let currentStep = 0;
        let iteration = 0;
        let isClusteringComplete = false;

        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
        const productTypes = ['水果类', '奶制品', '零食类', '日用品'];

        function initChart() {
            const ctx = document.getElementById('clusterChart').getContext('2d');
            
            kmeansChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '商品',
                            data: [],
                            backgroundColor: '#ccc',
                            borderColor: '#ccc',
                            pointRadius: 6
                        },
                        {
                            label: '中心点',
                            data: [],
                            backgroundColor: '#000',
                            borderColor: '#000',
                            pointRadius: 10,
                            pointStyle: 'triangle'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: '价格(元)' },
                            min: 0,
                            max: 50
                        },
                        y: {
                            title: { display: true, text: '重量(克)' },
                            min: 0,
                            max: 600
                        }
                    },
                    plugins: {
                        title: { display: true, text: '商品聚类图' }
                    }
                }
            });
        }

        function generateRandomData() {
            dataPoints = [];
            
            // 生成3个聚类的商品数据
            const centers = [
                {x: 8, y: 200},   // 水果类：价格低，重量中等
                {x: 15, y: 400},  // 奶制品：价格中等，重量大
                {x: 20, y: 150}   // 零食类：价格高，重量小
            ];
            
            const productNames = [
                '苹果', '橙子', '香蕉', '葡萄', '梨子', '桃子',
                '牛奶', '酸奶', '奶酪', '黄油', '奶油', '奶粉',
                '巧克力', '薯片', '饼干', '糖果', '坚果', '果干'
            ];
            
            for (let i = 0; i < 18; i++) {
                const cluster = Math.floor(i / 6);
                const x = centers[cluster].x + (Math.random() - 0.5) * 8;
                const y = centers[cluster].y + (Math.random() - 0.5) * 100;
                
                dataPoints.push({
                    x: Math.max(0, Math.min(50, x)),
                    y: Math.max(0, Math.min(600, y)),
                    name: productNames[i],
                    cluster: null
                });
            }
            
            updateChart();
            updateDataTable();
            resetClustering();
        }

        function updateChart() {
            if (!kmeansChart) return;
            
            const k = parseInt(document.getElementById('kValue').value);
            
            // 更新数据点
            const datasets = [];
            
            // 为每个聚类创建数据集
            for (let i = 0; i < k; i++) {
                const clusterData = dataPoints.filter(p => p.cluster === i);
                datasets.push({
                    label: `聚类${i+1}`,
                    data: clusterData,
                    backgroundColor: colors[i],
                    borderColor: colors[i],
                    pointRadius: 6
                });
            }
            
            // 未分配的点
            const unassigned = dataPoints.filter(p => p.cluster === null);
            if (unassigned.length > 0) {
                datasets.push({
                    label: '未分组',
                    data: unassigned,
                    backgroundColor: '#ccc',
                    borderColor: '#ccc',
                    pointRadius: 6
                });
            }
            
            // 中心点
            if (centroids.length > 0) {
                datasets.push({
                    label: '中心点',
                    data: centroids.map((c, i) => ({x: c.x, y: c.y})),
                    backgroundColor: '#000',
                    borderColor: '#000',
                    pointRadius: 10,
                    pointStyle: 'triangle'
                });
            }
            
            kmeansChart.data.datasets = datasets;
            kmeansChart.update();
        }

        function initializeCentroids() {
            const k = parseInt(document.getElementById('kValue').value);
            
            if (dataPoints.length < k) {
                alert(`需要至少${k}个商品才能分成${k}组！`);
                return;
            }
            
            centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: 5 + Math.random() * 30,
                    y: 100 + Math.random() * 300
                });
            }
            
            resetClustering();
            updateChart();
            showStep(1);
            
            document.getElementById('distanceInfo').innerHTML = 
                `<h4>🎯 中心点已初始化</h4>` +
                centroids.map((c, i) => 
                    `<p>中心点${i+1}: 价格${c.x.toFixed(1)}元，重量${c.y.toFixed(1)}克</p>`
                ).join('');
        }

        function assignClusters() {
            clusters = Array(centroids.length).fill(null).map(() => []);
            
            dataPoints.forEach(point => {
                let minDist = Infinity;
                let closestCluster = 0;
                
                centroids.forEach((centroid, i) => {
                    const dist = Math.sqrt(
                        Math.pow(point.x - centroid.x, 2) + 
                        Math.pow(point.y - centroid.y, 2)
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestCluster = i;
                    }
                });
                
                point.cluster = closestCluster;
                clusters[closestCluster].push(point);
            });
            
            updateChart();
            updateClusterInfo();
            showStep(2);
            
            let distanceDetails = '<h4>📏 距离计算详情</h4>';
            dataPoints.forEach((point, idx) => {
                const distances = centroids.map((c, i) => 
                    Math.sqrt(Math.pow(point.x - c.x, 2) + Math.pow(point.y - c.y, 2))
                );
                const minDist = Math.min(...distances);
                const cluster = distances.indexOf(minDist);
                
                distanceDetails += 
                    `<p>${point.name}(${point.x.toFixed(1)}元, ${point.y.toFixed(1)}克) → ` +
                    `分配到聚类${cluster+1}，距离=${minDist.toFixed(1)}</p>`;
            });
            
            document.getElementById('distanceInfo').innerHTML = distanceDetails;
        }

        function updateCentroids() {
            const newCentroids = [];
            
            clusters.forEach((cluster, i) => {
                if (cluster.length > 0) {
                    const avgX = cluster.reduce((sum, p) => sum + p.x, 0) / cluster.length;
                    const avgY = cluster.reduce((sum, p) => sum + p.y, 0) / cluster.length;
                    newCentroids.push({x: avgX, y: avgY});
                } else {
                    newCentroids.push(centroids[i]);
                }
            });
            
            centroids = newCentroids;
            updateChart();
            showStep(3);
            
            document.getElementById('distanceInfo').innerHTML = 
                '<h4>🔄 中心点已更新</h4>' +
                centroids.map((c, i) => 
                    `<p>新中心点${i+1}: 价格${c.x.toFixed(1)}元，重量${c.y.toFixed(1)}克</p>`
                ).join('');
        }

        function runOneStep() {
            if (centroids.length === 0) {
                alert('请先选择中心点！');
                return;
            }
            
            if (currentStep === 0) {
                assignClusters();
                currentStep = 1;
            } else if (currentStep === 1) {
                updateCentroids();
                currentStep = 2;
                iteration++;
            } else {
                assignClusters();
                currentStep = 1;
                iteration++;
            }
            
            // 检查是否收敛
            if (iteration > 5) {
                showStep(4);
                isClusteringComplete = true;
                document.getElementById('distanceInfo').innerHTML = 
                    `<h4>✅ 聚类完成！</h4>` +
                    `<p>共进行了${iteration}次迭代</p>` +
                    centroids.map((c, i) => 
                        `<p>最终中心点${i+1}: 价格${c.x.toFixed(1)}元，重量${c.y.toFixed(1)}克</p>`
                    ).join('');
            }
        }

        function runFullClustering() {
            if (centroids.length === 0) {
                alert('请先选择中心点！');
                return;
            }
            
            let maxIterations = 10;
            let changed = true;
            iteration = 0;
            
            while (changed && iteration < maxIterations) {
                const oldCentroids = JSON.parse(JSON.stringify(centroids));
                
                assignClusters();
                updateCentroids();
                
                changed = !centroids.every((c, i) => 
                    Math.abs(c.x - oldCentroids[i].x) < 0.1 && 
                    Math.abs(c.y - oldCentroids[i].y) < 0.1
                );
                
                iteration++;
            }
            
            showStep(4);
            isClusteringComplete = true;
            
            document.getElementById('distanceInfo').innerHTML = 
                `<h4>✅ 聚类完成！</h4>` +
                `<p>共进行了${iteration}次迭代</p>` +
                centroids.map((c, i) => 
                    `<p>最终中心点${i+1}: 价格${c.x.toFixed(1)}元，重量${c.y.toFixed(1)}克</p>`
                ).join('');
        }

        function showStep(step) {
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
            document.getElementById(`step${step}`).classList.add('active');
        }

        function predictCluster() {
            if (centroids.length === 0) {
                alert('请先运行聚类算法！');
                return;
            }
            
            const price = parseFloat(document.getElementById('newPrice').value);
            const weight = parseFloat(document.getElementById('newWeight').value);
            
            if (isNaN(price) || isNaN(weight)) {
                alert('请输入有效的数值！');
                return;
            }
            
            let minDist = Infinity;
            let closestCluster = 0;
            
            centroids.forEach((centroid, i) => {
                const dist = Math.sqrt(
                    Math.pow(price - centroid.x, 2) + 
                    Math.pow(weight - centroid.y, 2)
                );
                
                if (dist < minDist) {
                    minDist = dist;
                    closestCluster = i;
                }
            });
            
            document.getElementById('predictionResult').innerHTML = 
                `🎯 预测结果：这个商品属于<strong>聚类${closestCluster+1}</strong><br>` +
                `📊 价格${price}元，重量${weight}克 → 距离中心点${minDist.toFixed(1)}<br>` +
                `🎯 该聚类平均特征：价格${centroids[closestCluster].x.toFixed(1)}元，重量${centroids[closestCluster].y.toFixed(1)}克`;
        }

        function updateClusterInfo() {
            const k = parseInt(document.getElementById('kValue').value);
            
            for (let i = 0; i < k; i++) {
                const cluster = clusters[i] || [];
                const count = cluster.length;
                const avgPrice = count > 0 ? 
                    cluster.reduce((sum, p) => sum + p.x, 0) / count : 0;
                const avgWeight = count > 0 ? 
                    cluster.reduce((sum, p) => sum + p.y, 0) / count : 0;
                
                // 判断商品类型
                let type = '未知';
                if (avgPrice < 12 && avgWeight < 300) type = '水果类';
                else if (avgPrice < 20 && avgWeight > 300) type = '奶制品';
                else if (avgPrice > 15 && avgWeight < 200) type = '零食类';
                else type = '日用品';
                
                document.getElementById(`count${i+1}`).textContent = count;
                document.getElementById(`avgPrice${i+1}`).textContent = avgPrice.toFixed(1);
                document.getElementById(`avgWeight${i+1}`).textContent = avgWeight.toFixed(1);
                document.getElementById(`type${i+1}`).textContent = type;
            }
        }

        function updateDataTable() {
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            
            dataPoints.forEach((point, idx) => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${point.name}</td>
                    <td>${point.x.toFixed(1)}</td>
                    <td>${point.y.toFixed(1)}</td>
                    <td>${point.cluster !== null ? `聚类${point.cluster+1}` : '?'}</td>
                `;
            });
        }

        function resetClustering() {
            clusters = [];
            dataPoints.forEach(p => p.cluster = null);
            currentStep = 0;
            iteration = 0;
            isClusteringComplete = false;
            
            updateChart();
            updateClusterInfo();
            
            document.getElementById('distanceInfo').innerHTML = 
                '<h4>距离计算详情</h4><p>点击"执行一步"查看每个步骤的距离计算</p>';
            document.getElementById('predictionResult').innerHTML = 
                '输入商品数据，点击"预测分组"查看结果';
            
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
        }

        // 初始化
        window.onload = function() {
            initChart();
            generateRandomData();
        };
    </script>
</body>
</html>