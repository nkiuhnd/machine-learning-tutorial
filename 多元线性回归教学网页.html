<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多元线性回归学习工具</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 15px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 25px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 10px;
            background: #f9f9f9;
        }
        
        .chart-container {
            position: relative;
            height: 500px;
            margin: 15px 0;
        }
        
        .three-container {
            position: relative;
            height: 600px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background: #667eea;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #764ba2;
        }
        
        .info-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .formula {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .prediction-result {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #155724;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .data-table th, .data-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .data-table th {
            background: #667eea;
            color: white;
        }
        
        .feature-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .feature-importance {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🏠 多元线性回归学习工具</h1>
            <p>用房价预测理解多元线性回归</p>
        </div>
        
        <div class="section">
            <h2>📊 第一步：观察多元数据</h2>
            <p>我们来看看房子的各种特征如何影响房价：</p>
            
            <table class="data-table" style="margin: 10px 0;">
                <thead>
                    <tr>
                        <th>房子</th>
                        <th>面积(m²)</th>
                        <th>卧室数</th>
                        <th>房价(万元)</th>
                    </tr>
                </thead>
                <tbody id="dataTable">
                    <tr><td>房子A</td><td>80</td><td>2</td><td>200</td></tr>
                    <tr><td>房子B</td><td>100</td><td>3</td><td>280</td></tr>
                    <tr><td>房子C</td><td>120</td><td>3</td><td>350</td></tr>
                    <tr><td>房子D</td><td>90</td><td>2</td><td>220</td></tr>
                    <tr><td>房子E</td><td>150</td><td>4</td><td>450</td></tr>
                    <tr><td>房子F</td><td>70</td><td>2</td><td>180</td></tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>🤔 思考：一元 vs 多元的差别</h2>
            <div class="feature-comparison">
                <div class="feature-card">
                    <h3>📈 一元线性回归</h3>
                    <p><strong>只有一个特征</strong></p>
                    <p>公式：房价 = a × 面积 + b</p>
                    <p>缺点：只考虑面积，忽略其他重要因素</p>
                    <div class="info-panel">
                        <strong>举例：</strong>100m²的房子，一元回归可能预测250万，但实际可能因为房龄太老只值180万！
                    </div>
                </div>
                <div class="feature-card">
                    <h3>🏠 多元线性回归</h3>
                    <p><strong>多个特征一起考虑</strong></p>
                    <p>公式：房价 = a₁×面积 + a₂×卧室 + a₃×房龄 + a₄×距离 + b</p>
                    <p>优点：综合考虑所有因素，预测更准确</p>
                    <div class="info-panel">
                        <strong>举例：</strong>同样的100m²房子，多元回归会同时考虑房龄、距离等因素，给出更准确的180万预测！
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>📈 第二步：可视化多元关系（3D版）</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="toggleDataPoints()" id="showDataBtn" style="background: #dc3545; color: white; font-weight: bold; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                    👁️ 显示3D房价数据
                </button>
                <button onclick="calculateBestFitModel()" style="margin: 5px 0; background: #28a745; font-weight: bold;">🔍 计算多元回归模型</button>
                <button onclick="resetData()" style="margin: 5px 0;">重置数据</button>
                <button onclick="generateRandomData()" style="margin: 5px 0;">生成随机数据</button>
                <input type="number" id="newArea" placeholder="面积(m²)" min="50" max="200" step="5" style="margin: 5px 0;">
                <input type="number" id="newRooms" placeholder="卧室数" min="1" max="5" step="1" style="margin: 5px 0;">
                <input type="number" id="newPrice" placeholder="房价(万元)" min="100" max="500" step="10" style="margin: 5px 0;">
                <button onclick="addData()" style="margin: 5px 0;">手动添加数据</button>
                
                <div>
                    <input type="number" id="predArea" placeholder="面积(m²)" min="50" max="200" step="5" style="margin: 5px 0;">
                    <input type="number" id="predRooms" placeholder="卧室数" min="1" max="5" step="1" style="margin: 5px 0;">
                    <button onclick="makePrediction()" style="margin: 5px 0;">预测房价</button>
                </div>
                
                <div id="predictionResult" class="prediction-result" style="margin: 10px 0;">请输入面积和卧室数，然后点击"预测房价"按钮</div>
                
                
            </div>
            <div class="three-container" id="threeContainer"></div>
        </div>
        

        
        <div class="section">
            <h2>📊 特征重要性分析</h2>
            <div id="featureImportance" class="feature-importance">
                <p>💡 计算多元回归模型后，这里会显示每个特征对房价的影响程度：</p>
                <div id="importanceDetails">点击"计算多元回归模型"查看特征权重</div>
                <div id="modelAccuracy" style="margin-top: 10px; font-weight: bold; color: #d63384;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>🔢 计算结果</h2>
            <div class="formula" id="formulaDisplay" style="font-size: 14px;">
                正在计算中...
            </div>
        </div>
        
        <div class="section">
            <h2>🤖 与人工智能的关系</h2>
            <div style="background: #f8d7da; padding: 15px; border-radius: 8px; border-left: 5px solid #dc3545;">
                <h3>🧠 AI如何用多元线性回归？</h3>
                <p><strong>淘宝推荐：</strong>根据你的年龄、性别、浏览历史等多个特征，预测你可能喜欢的商品</p>
                <p><strong>抖音推荐：</strong>根据你的观看时长、点赞类型、关注用户等多个维度，推荐你可能感兴趣的视频</p>
                <p><strong>医疗诊断：</strong>根据年龄、血压、血糖、胆固醇等多个指标，预测疾病风险</p>
                
                <h3>🎯 多元回归的魔力</h3>
                <p>现实世界的问题往往涉及多个因素，就像房价不仅看面积，还要看地段、房龄等。多元线性回归让AI能够像人类专家一样，综合考虑各种因素做出更准确的判断！</p>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let scatterPoints = [];
        let regressionPlane;
        let dataPointsVisible = false;
        let modelCalculated = false;
        
        let houseData = [
            {area: 80, rooms: 2, price: 200, name: '房子A'},
            {area: 100, rooms: 3, price: 280, name: '房子B'},
            {area: 120, rooms: 3, price: 350, name: '房子C'},
            {area: 90, rooms: 2, price: 220, name: '房子D'},
            {area: 150, rooms: 4, price: 450, name: '房子E'},
            {area: 70, rooms: 2, price: 180, name: '房子F'}
        ];
        
        function init3DScene() {
            const container = document.getElementById('threeContainer');
            
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            // 创建相机 - 调整视角以更好地观察坐标系和回归平面
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            // 获取数据范围来调整相机位置
            const areas = houseData.map(d => d.area);
            const prices = houseData.map(d => d.price);
            const roomDataArray = houseData.map(d => d.rooms);
            
            const maxArea = Math.max(...areas);
            const maxPrice = Math.max(...prices);
            const maxRooms = Math.max(...roomDataArray);
            
            // 根据数据范围调整相机位置
            const centerX = maxArea / 2;
            const centerY = maxPrice / 2;
            const centerZ = maxRooms / 2;
            
            camera.position.set(centerX + 50, centerY + 50, centerZ + 50);
            camera.lookAt(centerX, centerY, centerZ);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // 添加控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.target.set(centerX, centerY, centerZ); // 设置控制中心点
            
            // 创建自定义坐标系
            createCustomAxes();
            
            // 添加网格 - 在XZ平面上，根据数据范围调整大小
            const gridSize = Math.max(maxArea, maxPrice, maxRooms * 10) + 20;
            const gridHelper = new THREE.GridHelper(gridSize, 20, 0xcccccc, 0xcccccc);
            gridHelper.position.set(centerX, 0, centerZ);
            scene.add(gridHelper);
            
            // 添加坐标轴标签和刻度
            createAxisLabels();
            
            // 添加图例说明
            createLegend();
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(100, 100, 100);
            scene.add(directionalLight);
            
            animate();
        }
        
        function createCustomAxes() {
            // 创建自定义坐标系 - 左下角为原点，使用原始数据值
            const axesGroup = new THREE.Group();
            
            // 获取数据范围
            const areas = houseData.map(d => d.area);
            const prices = houseData.map(d => d.price);
            const roomDataArray = houseData.map(d => d.rooms);
            
            const maxArea = Math.max(...areas);
            const maxPrice = Math.max(...prices);
            const maxRooms = Math.max(...roomDataArray);
            
            // X轴（面积）- 红色，向右，使用原始面积值
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(maxArea + 20, 0, 0)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            axesGroup.add(xAxis);
            
            // Y轴（价格）- 绿色，向上，使用原始价格值
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, maxPrice + 50, 0)
            ]);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            axesGroup.add(yAxis);
            
            // Z轴（卧室数）- 蓝色，向内，使用原始卧室数值的50倍（调整比例）
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, (maxRooms + 1) * 50)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            axesGroup.add(zAxis);
            
            // 添加刻度标记 - 使用实际数据值
            // X轴刻度（面积）
            for (let i = 0; i <= Math.ceil(maxArea / 20); i++) {
                const x = i * 20;
                if (x <= maxArea + 20) {
                    const xTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, -2, 0),
                        new THREE.Vector3(x, 2, 0)
                    ]);
                    const xTick = new THREE.Line(xTickGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
                    axesGroup.add(xTick);
                }
            }
            
            // Y轴刻度（价格）
            for (let i = 0; i <= Math.ceil(maxPrice / 50); i++) {
                const y = i * 50;
                if (y <= maxPrice + 50) {
                    const yTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(-2, y, 0),
                        new THREE.Vector3(2, y, 0)
                    ]);
                    const yTick = new THREE.Line(yTickGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    axesGroup.add(yTick);
                }
            }
            
            // Z轴刻度（卧室数）- 放大50倍
            for (let i = 0; i <= maxRooms + 1; i++) {
                const z = i * 50;
                const zTickGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -2, z),
                    new THREE.Vector3(0, 2, z)
                ]);
                const zTick = new THREE.Line(zTickGeometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                axesGroup.add(zTick);
            }
            
            scene.add(axesGroup);
        }
        
        function createAxisLabels() {
            // 创建文字精灵函数
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(15, 4, 1);
                
                return sprite;
            }
            
            // 创建刻度标签函数
            function createTickLabel(text, color = '#666666') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 32;
                
                context.font = '12px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 64, 16);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(8, 2, 1);
                
                return sprite;
            }
            
            // 获取数据范围
            const areas = houseData.map(d => d.area);
            const prices = houseData.map(d => d.price);
            const roomDataArray = houseData.map(d => d.rooms);
            
            const maxArea = Math.max(...areas);
            const maxPrice = Math.max(...prices);
            const maxRooms = Math.max(...roomDataArray);
            
            // 主坐标轴标签
            const xLabel = createTextSprite('面积 (m²)', '#ff0000');
            xLabel.position.set(maxArea / 2, -8, 0);
            scene.add(xLabel);
            
            const yLabel = createTextSprite('价格 (万元)', '#00ff00');
            yLabel.position.set(-8, maxPrice / 2, 0);
            scene.add(yLabel);
            
            const zLabel = createTextSprite('卧室数', '#0000ff');
            zLabel.position.set(0, -8, (maxRooms / 2) * 50);
            scene.add(zLabel);
            
            // 添加刻度标签 - 使用实际数据值
            // X轴刻度标签（面积）
            for (let i = 0; i <= Math.ceil(maxArea / 20); i++) {
                const value = i * 20;
                if (value <= maxArea + 20) {
                    const xTickLabel = createTickLabel(value.toString(), '#ff0000');
                    xTickLabel.position.set(value, -5, 0);
                    scene.add(xTickLabel);
                }
            }
            
            // Y轴刻度标签（价格）
            for (let i = 0; i <= Math.ceil(maxPrice / 50); i++) {
                const value = i * 50;
                if (value <= maxPrice + 50) {
                    const yTickLabel = createTickLabel(value.toString(), '#00ff00');
                    yTickLabel.position.set(-5, value, 0);
                    scene.add(yTickLabel);
                }
            }
            
            // Z轴刻度标签（卧室数）- 放大50倍
            for (let i = 0; i <= maxRooms + 1; i++) {
                const zTickLabel = createTickLabel(i.toString(), '#0000ff');
                zTickLabel.position.set(0, -5, i * 50);
                scene.add(zTickLabel);
            }
        }
        
        function createLegend() {
            // 创建图例HTML元素
            const legendHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 12px; z-index: 100; max-width: 280px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">📊 3D坐标系说明</h4>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border-radius: 50%; margin-right: 8px;"></span>
                        <span>红色圆点 = 实际房价数据</span>
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: rgba(33, 150, 243, 0.4); margin-right: 8px;"></span>
                        <span>蓝色平面 = 多元回归预测模型</span>
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #00ff00; border-radius: 50%; margin-right: 8px;"></span>
                        <span>绿色圆点 = 预测房价</span>
                    </div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>坐标系（左下角为原点）：</strong></div>
                    <div style="margin: 3px 0; color: #ff0000;">📏 X轴（红色）：向右 = 面积增加 (70-150m²)</div>
                    <div style="margin: 3px 0; color: #00ff00;">💰 Y轴（绿色）：向上 = 价格增加 (180-450万元)</div>
                    <div style="margin: 3px 0; color: #0000ff;">🏠 Z轴（蓝色）：向内 = 卧室数增加 (2-4间)</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>坐标映射：</strong></div>
                    <div style="margin: 3px 0;">面积：直接使用原始值 (m²)</div>
                    <div style="margin: 3px 0;">价格：直接使用原始值 (万元)</div>
                    <div style="margin: 3px 0;">卧室数：原始值×50 (间)</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0; color: #666;">
                        💡 <em>鼠标拖拽旋转视角，滚轮缩放</em>
                    </div>
                </div>
            `;
            
            // 添加图例到容器
            const container = document.getElementById('threeContainer');
            const legendDiv = document.createElement('div');
            legendDiv.innerHTML = legendHTML;
            container.style.position = 'relative';
            container.appendChild(legendDiv.firstElementChild);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function toggleDataPoints() {
            if (!dataPointsVisible) {
                show3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = '🙈 隐藏3D房价数据';
                document.getElementById('showDataBtn').style.background = '#6c757d';
                dataPointsVisible = true;
            } else {
                hide3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = '👁️ 显示3D房价数据';
                document.getElementById('showDataBtn').style.background = '#dc3545';
                dataPointsVisible = false;
            }
        }
        
        function show3DDataPoints() {
            // 清除现有数据点
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // 添加新的数据点，直接使用原始数据值
            houseData.forEach((house, index) => {
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x330000
                });
                const sphere = new THREE.Mesh(geometry, material);
                
                // 直接使用原始数据值，不进行映射
                sphere.position.set(
                    house.area,      // 面积直接使用原始值
                    house.price,     // 价格直接使用原始值
                    house.rooms * 50 // 卧室数放大50倍
                );
                
                // 添加数据标签（简化显示）
                const label = createDataLabel(`${house.name}\n${house.area}m², ${house.price}万`);
                label.position.set(house.area + 3, house.price, house.rooms * 50);
                scene.add(label);
                
                scene.add(sphere);
                scatterPoints.push(sphere);
            });
            
            // 将数据点分组命名，便于管理
            const dataGroup = new THREE.Group();
            dataGroup.name = 'dataPoints';
            scatterPoints.forEach(point => dataGroup.add(point));
            scene.add(dataGroup);
        }
        
        function createDataLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 40;
            
            // 绘制背景
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            context.fillRect(0, 0, 200, 40);
            context.strokeStyle = '#666';
            context.lineWidth = 1;
            context.strokeRect(0, 0, 200, 40);
            
            // 绘制文字
            context.font = 'bold 10px Arial';
            context.fillStyle = '#333';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            const lines = text.split('\n');
            lines.forEach((line, index) => {
                context.fillText(line, 100, 10 + index * 12);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 1.6, 1);
            
            return sprite;
        }
        
        function hide3DDataPoints() {
            // 清除数据点
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // 清除所有标签
            if (scene) {
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
        }
        


        function calculateMultipleRegression() {
            // 二元线性回归计算（面积和卧室数）
            const n = houseData.length;
            
            // 计算均值
            const meanArea = houseData.reduce((sum, d) => sum + d.area, 0) / n;
            const meanRooms = houseData.reduce((sum, d) => sum + d.rooms, 0) / n;
            const meanPrice = houseData.reduce((sum, d) => sum + d.price, 0) / n;
            
            // 计算协方差和方差
            let covAreaPrice = 0, covRoomsPrice = 0, varArea = 0, varRooms = 0, covAreaRooms = 0;
            
            houseData.forEach(d => {
                covAreaPrice += (d.area - meanArea) * (d.price - meanPrice);
                covRoomsPrice += (d.rooms - meanRooms) * (d.price - meanPrice);
                varArea += (d.area - meanArea) ** 2;
                varRooms += (d.rooms - meanRooms) ** 2;
                covAreaRooms += (d.area - meanArea) * (d.rooms - meanRooms);
            });
            
            // 解二元线性方程组
            const denominator = varArea * varRooms - covAreaRooms ** 2;
            const a1 = (covAreaPrice * varRooms - covRoomsPrice * covAreaRooms) / denominator;
            const a2 = (covRoomsPrice * varArea - covAreaPrice * covAreaRooms) / denominator;
            const b = meanPrice - a1 * meanArea - a2 * meanRooms;
            
            return {a1, a2, b};
        }
        
        function calculateBestFitModel() {
            if (!dataPointsVisible) {
                alert('请先点击"显示房价数据"按钮！');
                return;
            }
            
            if (houseData.length < 3) {
                alert('需要至少3个数据点才能计算多元回归模型！');
                return;
            }
            
            document.getElementById('formulaDisplay').innerHTML = 
                '🧮 正在用多元线性回归计算最佳模型...';
            
            const coeffs = calculateMultipleRegression();
            
            // 直接显示3D回归平面（移除Chart.js依赖）
            setTimeout(() => {
                // 显示二元回归公式
                document.getElementById('formulaDisplay').innerHTML = 
                    `📊 二元线性回归结果：<br>房价 = ${coeffs.a1.toFixed(1)}×面积 + ${coeffs.a2.toFixed(1)}×卧室数 + ${coeffs.b.toFixed(1)}<br><br>🎯 这个模型综合考虑了面积和卧室数！`;
                
                // 显示特征重要性（二维）
                document.getElementById('importanceDetails').innerHTML = 
                    `<strong>🏆 特征重要性：</strong><br>
                    1. 面积：每增加1m²，房价+${coeffs.a1.toFixed(1)}万元<br>
                    2. 卧室数：每多1间，房价+${coeffs.a2.toFixed(1)}万元`;
                
                document.getElementById('modelAccuracy').innerHTML = 
                    `📈 3D模型展示：红色点=实际数据，蓝色平面=回归预测`;
                
                // 显示3D回归平面
                showRegressionPlane(coeffs);
                
                modelCalculated = true;
            }, 500);
        }


        
        function makePrediction() {
            console.log('=== 开始预测 ===');
            console.log('模型是否已计算:', modelCalculated);
            
            if (!modelCalculated) {
                console.log('⚠️ 模型未计算，尝试自动计算模型...');
                // 尝试自动计算模型
                try {
                    const coeffs = calculateMultipleRegression();
                    if (coeffs && coeffs.a1 !== undefined) {
                        console.log('✅ 自动计算模型成功');
                        modelCalculated = true;
                    } else {
                        alert('请先点击"计算多元回归模型"按钮！');
                        return;
                    }
                } catch (error) {
                    console.log('❌ 自动计算模型失败:', error);
                    alert('请先点击"计算多元回归模型"按钮！');
                    return;
                }
            }
            
            const area = parseFloat(document.getElementById('predArea').value);
            const rooms = parseFloat(document.getElementById('predRooms').value);
            
            console.log('输入参数:', {area, rooms});
            
            if (isNaN(area) || isNaN(rooms)) {
                alert('请输入面积和卧室数！');
                return;
            }
            
            // 清除之前的预测点
            if (scene) {
                const oldPredictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                oldPredictionPoints.forEach(point => scene.remove(point));
                
                // 清除预测点标签
                const oldPredictionLabels = scene.children.filter(obj => 
                    obj.type === 'Sprite' && obj.userData && obj.userData.isPrediction
                );
                oldPredictionLabels.forEach(label => scene.remove(label));
                
                // 清除预测点辅助线
                const oldPredictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                oldPredictionHelpers.forEach(helper => scene.remove(helper));
            }
            
            // 使用二元回归系数进行预测
            const coeffs = calculateMultipleRegression();
            const predictedPrice = coeffs.a1 * area + coeffs.a2 * rooms + coeffs.b;
            

            
            // 在3D场景中显示预测点
            const predictionGeometry = new THREE.SphereGeometry(2, 16, 16); // 减小预测点大小
            const predictionMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x003300,
                transparent: true,
                opacity: 0.8 // 增加透明度
            });
            const predictionSphere = new THREE.Mesh(predictionGeometry, predictionMaterial);
            
            // 直接使用原始数据值，不进行映射
            const predictionX = area;           // 面积直接使用原始值
            const predictionY = predictedPrice; // 价格直接使用原始值
            const predictionZ = rooms * 50;     // 卧室数放大50倍
            
            predictionSphere.position.set(predictionX, predictionY, predictionZ);
            
            // 添加预测点标签
            const predictionLabel = createDataLabel(`预测\n${area}m², ${predictedPrice.toFixed(1)}万`);
            predictionLabel.position.set(predictionX + 5, predictionY, predictionZ);
            predictionLabel.userData = { isPrediction: true }; // 添加标识
            scene.add(predictionLabel);
            scene.add(predictionSphere);
            
            // 添加辅助线，从预测点垂直向下到平面
            const helperLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(predictionX, predictionY, predictionZ),
                new THREE.Vector3(predictionX, predictionY - 10, predictionZ) // 向下延伸10个单位
            ]);
            const helperLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                linewidth: 2,
                transparent: true,
                opacity: 0.6
            });
            const helperLine = new THREE.Line(helperLineGeometry, helperLineMaterial);
            helperLine.userData = { isPrediction: true };
            scene.add(helperLine);
            
            // 添加调试信息
            console.log('=== 预测点信息 ===');
            console.log('预测点位置:', {x: predictionX, y: predictionY, z: predictionZ});
            console.log('预测结果:', {area, rooms, predictedPrice});
            
            // 验证预测点是否在回归平面上
            // 使用与平面相同的数学原理
            const expectedY = coeffs.a1 * area + coeffs.a2 * rooms + coeffs.b;
            const deviation = Math.abs(predictionY - expectedY);
            
            // 验证数学计算
            console.log('=== 数学验证 ===');
            console.log('回归方程: 价格 =', coeffs.a1, '×', area, '+', coeffs.a2, '×', rooms, '+', coeffs.b);
            console.log('预测价格:', predictedPrice);
            console.log('3D坐标系映射:');
            console.log('- X轴 (面积):', area);
            console.log('- Y轴 (价格):', predictedPrice);
            console.log('- Z轴 (卧室数):', rooms * 50);
            
            console.log('预测点验证:');
            console.log('- 预测点坐标:', {x: predictionX, y: predictionY, z: predictionZ});
            console.log('- 回归平面在该点的Y值:', expectedY);
            console.log('- 偏差:', deviation);
            console.log('- 预测点是否在平面上:', deviation < 0.1 ? '是' : '否');
            
            // 验证预测点是否在平面覆盖范围内
            const roomDataArray = houseData.map(d => d.rooms);
            const minRooms = Math.min(...roomDataArray);
            const maxRooms = Math.max(...roomDataArray);
            
            const planeCenterZ = (minRooms + maxRooms) / 2 * 50; // 平面中心Z坐标，放大50倍
            const planeDepth = (maxRooms - minRooms) * 150; // 平面深度，对应Z轴放大50倍
            const inPlaneRange = predictionZ >= planeCenterZ - planeDepth/2 && predictionZ <= planeCenterZ + planeDepth/2;
            console.log('- 预测点是否在平面覆盖范围内:', inPlaneRange ? '是' : '否');
            console.log('- 平面Z轴范围:', {min: planeCenterZ - planeDepth/2, max: planeCenterZ + planeDepth/2});
            console.log('- 预测点Z坐标:', predictionZ);
            console.log('- 平面中心Z坐标:', planeCenterZ);
            console.log('- 平面深度:', planeDepth);
            
            if (deviation > 0.1) {
                console.log('⚠️ 警告：预测点偏离回归平面，可能需要检查平面计算');
            }
            if (!inPlaneRange) {
                console.log('⚠️ 警告：预测点超出平面覆盖范围，可能看不到平面');
            }
            
            // 精确验证预测点是否在平面上
            console.log('=== 精确平面验证 ===');
            
            // 获取平面信息
            const plane = scene.getObjectByName('regressionPlane');
            if (plane) {
                const planeCenterX = plane.position.x;
                const planeCenterY = plane.position.y;
                const planeCenterZ = plane.position.z;
                
                // 计算预测点在平面坐标系中的位置
                const relativeX = predictionX - planeCenterX;
                const relativeY = predictionY - planeCenterY;
                const relativeZ = predictionZ - planeCenterZ;
                
                // 根据平面旋转计算预测点应该在的Y坐标
                const expectedYOnPlane = planeCenterY + 
                    relativeX * Math.tan(plane.rotation.z) + 
                    relativeZ * Math.tan(plane.rotation.x);
                
                const planeDeviation = Math.abs(predictionY - expectedYOnPlane);
                console.log('平面几何验证:');
                console.log('- 平面中心位置:', {x: planeCenterX, y: planeCenterY, z: planeCenterZ});
                console.log('- 预测点相对平面中心:', {x: relativeX, y: relativeY, z: relativeZ});
                console.log('- 平面旋转角度:', {x: plane.rotation.x, z: plane.rotation.z});
                console.log('- 预测点Y坐标:', predictionY);
                console.log('- 平面上对应Y坐标:', expectedYOnPlane);
                console.log('- 几何偏差:', planeDeviation);
                console.log('- 预测点是否在几何平面上:', planeDeviation < 0.1 ? '是' : '否');
            } else {
                console.log('⚠️ 警告：找不到回归平面，无法进行几何验证');
            }
            
            // 显示预测结果
            const predictionDiv = document.getElementById('predictionResult');
            console.log('=== 预测结果显示 ===');
            console.log('预测结果区域:', predictionDiv);
            if (predictionDiv) {
                const resultText = `🎯 预测结果：这套房子的价格大约是${predictedPrice.toFixed(1)}万元`;
                predictionDiv.innerHTML = resultText;
                console.log('设置预测结果文本:', resultText);
                console.log('预测结果区域内容:', predictionDiv.innerHTML);
            } else {
                console.log('⚠️ 警告：找不到预测结果区域');
            }
        }

        function addData() {
            const area = parseFloat(document.getElementById('newArea').value);
            const rooms = parseFloat(document.getElementById('newRooms').value);
            const price = parseFloat(document.getElementById('newPrice').value);
            
            if (isNaN(area) || isNaN(rooms) || isNaN(price)) {
                alert('请输入有效的数字！');
                return;
            }
            
            houseData.push({area, rooms, price, name: '新房子'});
            
            // 更新表格
            const tbody = document.getElementById('dataTable');
            const row = tbody.insertRow();
            row.innerHTML = `<td>新房子</td><td>${area}</td><td>${rooms}</td><td>${price}</td>`;
            
            // 清除3D场景中的所有元素
            if (scene) {
                // 清除数据点
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // 清除回归平面
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // 清除回归平面边框
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // 清除预测点
                const predictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                predictionPoints.forEach(point => scene.remove(point));
                
                // 清除预测点辅助线
                const predictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                predictionHelpers.forEach(helper => scene.remove(helper));
                
                // 清除所有标签（通过类型过滤）
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = '已添加新数据！请重新计算模型';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = '请输入房子特征进行预测';
            }
        }

        function resetData() {
            houseData = [
                {area: 80, rooms: 2, price: 200, name: '房子A'},
                {area: 100, rooms: 3, price: 280, name: '房子B'},
                {area: 120, rooms: 3, price: 350, name: '房子C'},
                {area: 90, rooms: 2, price: 220, name: '房子D'},
                {area: 150, rooms: 4, price: 450, name: '房子E'},
                {area: 70, rooms: 2, price: 180, name: '房子F'}
            ];
            
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = `
                <tr><td>房子A</td><td>80</td><td>2</td><td>200</td></tr>
                <tr><td>房子B</td><td>100</td><td>3</td><td>280</td></tr>
                <tr><td>房子C</td><td>120</td><td>3</td><td>350</td></tr>
                <tr><td>房子D</td><td>90</td><td>2</td><td>220</td></tr>
                <tr><td>房子E</td><td>150</td><td>4</td><td>450</td></tr>
                <tr><td>房子F</td><td>70</td><td>2</td><td>180</td></tr>
            `;
            
            // 清除3D场景中的所有元素
            if (scene) {
                // 清除数据点
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // 清除回归平面
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // 清除回归平面边框
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // 清除预测点
                const predictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                predictionPoints.forEach(point => scene.remove(point));
                
                // 清除预测点辅助线
                const predictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                predictionHelpers.forEach(helper => scene.remove(helper));
                
                // 清除所有标签（通过类型过滤）
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            dataPointsVisible = false;
            modelCalculated = false;
            
            document.getElementById('showDataBtn').innerHTML = '👁️ 显示3D房价数据';
            document.getElementById('showDataBtn').style.background = '#dc3545';
            document.getElementById('formulaDisplay').innerHTML = '正在计算中...';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = '请输入面积和卧室数进行预测';
            }
            document.getElementById('importanceDetails').innerHTML = '点击"计算多元回归模型"查看特征权重';
            document.getElementById('modelAccuracy').innerHTML = '';
        }

        function generateRandomData() {
            houseData = [];
            const names = ['房子G', '房子H', '房子I', '房子J', '房子K', '房子L'];
            
            // 生成更多样化的随机数据
            console.log('=== 生成随机数据 ===');
            
            // 为整个数据集选择一组固定的系数，确保数据的一致性
            const areaCoeff = (Math.random() * 3) + 2; // 2-5，面积对价格的正向影响
            const roomCoeff = (Math.random() * 40) + 20; // 20-60，卧室数对价格的正向影响
            const basePrice = (Math.random() * 150) + 100; // 100-250，基础价格
            
            console.log(`使用系数: 面积${areaCoeff.toFixed(1)}, 卧室${roomCoeff.toFixed(1)}, 基础价格${basePrice.toFixed(1)}`);
            
            for (let i = 0; i < 6; i++) {
                const area = Math.floor(Math.random() * 100) + 60; // 60-160
                const rooms = Math.floor(Math.random() * 3) + 2; // 2-4
                
                // 添加随机噪声，但保持正系数
                const noise = (Math.random() - 0.5) * 80; // -40到40的随机噪声
                
                const price = Math.floor(area * areaCoeff + rooms * roomCoeff + basePrice + noise);
                
                console.log(`房子${names[i]}: 面积${area}m², 卧室${rooms}间, 价格${price}万`);
                
                houseData.push({area, rooms, price, name: names[i]});
            }
            
            // 更新表格
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            houseData.forEach(house => {
                const row = tbody.insertRow();
                row.innerHTML = `<td>${house.name}</td><td>${house.area}</td><td>${house.rooms}</td><td>${house.price}</td>`;
            });
            
            // 清除3D场景中的所有元素
            if (scene) {
                // 清除数据点
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // 清除回归平面
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // 清除回归平面边框
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // 清除预测点
                const predictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                predictionPoints.forEach(point => scene.remove(point));
                
                // 清除预测点辅助线
                const predictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                predictionHelpers.forEach(helper => scene.remove(helper));
                
                // 清除所有标签（通过类型过滤）
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = '已生成随机数据！请重新计算模型';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = '请输入面积和卧室数进行预测';
            }
        }

        function showRegressionPlane(coeffs) {
            if (!scene) return;
            
            // 移除旧的回归平面
            const oldPlane = scene.getObjectByName('regressionPlane');
            if (oldPlane) scene.remove(oldPlane);
            const oldEdges = scene.getObjectByName('regressionPlaneEdges');
            if (oldEdges) scene.remove(oldEdges);
            
            // 获取实际数据范围
            const areas = houseData.map(d => d.area);
            const roomDataArray = houseData.map(d => d.rooms);
            const prices = houseData.map(d => d.price);
            
            const minArea = Math.min(...areas);
            const maxArea = Math.max(...areas);
            const minRooms = Math.min(...roomDataArray);
            const maxRooms = Math.max(...roomDataArray);
            
            // 平面尺寸：使用实际数据范围，大幅扩大
            const areaRange = maxArea - minArea;
            const roomRange = maxRooms - minRooms;
            
            const planeWidth = areaRange * 3;   // 扩大3倍
            const planeDepth = roomRange * 150; // 扩大150倍（对应Z轴放大50倍）
            
            console.log('=== 平面尺寸计算 ===');
            console.log('数据范围:', {minArea, maxArea, minRooms, maxRooms});
            console.log('平面尺寸:', {width: planeWidth, depth: planeDepth});
            
            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeDepth, 32, 32);
            
            // 创建平面材质 - 增加透明度，让数据点更清晰
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.name = 'regressionPlane';
            
            // 计算平面中心位置 - 使用数据范围的中心，Z轴放大50倍
            const centerX = (minArea + maxArea) / 2;
            const centerZ = (minRooms + maxRooms) / 2 * 50; // Z轴放大50倍
            
            // 根据回归方程计算中心点的Y坐标
            const centerY = coeffs.a1 * centerX + coeffs.a2 * (centerZ / 50) + coeffs.b; // 注意这里要除以50，因为Z轴放大了50倍
            
            plane.position.set(centerX, centerY, centerZ);
            
            // 计算3D坐标系中的斜率
            // 回归方程：price = a1*area + a2*rooms + b
            // 在3D坐标系中：X轴=面积，Y轴=价格，Z轴=卧室数*50
            // 所以：Y = a1*X + a2*(Z/50) + b
            // 对X求偏导：∂Y/∂X = a1
            // 对Z求偏导：∂Y/∂Z = a2/50
            const slopeX = coeffs.a1;  // X轴斜率（面积影响）
            const slopeZ = coeffs.a2 / 50;  // Z轴斜率（卧室影响，因为Z轴放大了50倍）
            
            console.log('3D坐标系斜率 (Z轴放大50倍):');
            console.log('- X轴斜率 (面积影响):', slopeX);
            console.log('- Z轴斜率 (卧室影响):', slopeZ);
            console.log('- 回归系数:', {a1: coeffs.a1, a2: coeffs.a2, b: coeffs.b});
            
            // 计算旋转角度 - 使用反正切函数
            const rotationX = Math.atan(slopeZ); // Z轴方向的倾斜
            const rotationZ = Math.atan(slopeX); // X轴方向的倾斜
            
            // 限制旋转角度，避免平面过度倾斜
            const maxRotation = Math.PI / 6; // 30度，允许更大的倾斜
            plane.rotation.x = Math.max(-maxRotation, Math.min(maxRotation, rotationX));
            plane.rotation.z = Math.max(-maxRotation, Math.min(maxRotation, rotationZ));
            
            console.log('平面旋转角度:');
            console.log('- X轴旋转 (面积影响):', plane.rotation.z, '弧度');
            console.log('- Z轴旋转 (卧室影响):', plane.rotation.x, '弧度');
            console.log('- 旋转限制: ±30度 (±π/6弧度)');
            
            // 验证平面是否正确通过数据点
            console.log('=== 平面验证 ===');
            houseData.forEach((house, index) => {
                const expectedY = coeffs.a1 * house.area + coeffs.a2 * house.rooms + coeffs.b;
                const actualY = house.price;
                const deviation = Math.abs(actualY - expectedY);
                console.log(`数据点${index + 1}: 实际Y=${actualY.toFixed(2)}, 平面Y=${expectedY.toFixed(2)}, 偏差=${deviation.toFixed(2)}`);
            });
            
            // 验证平面覆盖范围
            console.log('=== 平面覆盖范围验证 ===');
            console.log('平面中心位置:', {x: centerX, y: centerY, z: centerZ});
            console.log('平面尺寸:', {width: planeWidth, depth: planeDepth});
            console.log('Z轴覆盖范围:', {min: centerZ - planeDepth/2, max: centerZ + planeDepth/2});
            console.log('卧室数覆盖范围:', {min: (centerZ - planeDepth/2)/50, max: (centerZ + planeDepth/2)/50});
            
            scene.add(plane);
            
            // 添加边框 - 增加边框宽度，让平面更清晰
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x1976D2, 
                linewidth: 3 
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.position.copy(plane.position);
            edges.rotation.copy(plane.rotation);
            edges.name = 'regressionPlaneEdges';
            scene.add(edges);
            
            // 添加调试信息
            console.log('回归系数:', coeffs);
            console.log('平面位置:', plane.position);
            console.log('平面旋转:', {x: plane.rotation.x, z: plane.rotation.z});
            console.log('斜率:', {slopeX, slopeZ});
            
            // 可视化建议
            console.log('=== 可视化建议 ===');
            console.log('1. 蓝色平面应该反映面积和卧室数对价格的综合影响');
            console.log('2. 数据点应该大致分布在平面附近');
            console.log('3. 平面倾斜方向应该与数据趋势一致');
        }
        


        // 测试回归模型
        function testRegressionModel() {
            console.log('=== 测试回归模型 ===');
            const coeffs = calculateMultipleRegression();
            console.log('回归系数:', coeffs);
            
            // 测试几个数据点
            const testPoints = [
                {area: 80, rooms: 2, price: 200},
                {area: 100, rooms: 3, price: 280},
                {area: 120, rooms: 3, price: 350}
            ];
            
            testPoints.forEach((point, index) => {
                const predictedPrice = coeffs.a1 * point.area + coeffs.a2 * point.rooms + coeffs.b;
                console.log(`测试点${index + 1}: 面积${point.area}m², 卧室${point.rooms}间, 实际价格${point.price}万, 预测价格${predictedPrice.toFixed(1)}万`);
            });
        }
        

        
        // 初始化
        window.onload = function() {
            init3DScene();
            // 延迟执行测试和自动计算模型
            setTimeout(() => {
                testRegressionModel();
                // 自动计算模型
                try {
                    const coeffs = calculateMultipleRegression();
                    if (coeffs && coeffs.a1 !== undefined) {
                        console.log('✅ 页面加载时自动计算模型成功');
                        modelCalculated = true;
                        // 显示3D回归平面
                        showRegressionPlane(coeffs);
                    }
                } catch (error) {
                    console.log('❌ 页面加载时自动计算模型失败:', error);
                }
            }, 1000);
        };
    </script>
</body>
</html>