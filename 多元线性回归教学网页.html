<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šå…ƒçº¿æ€§å›å½’å­¦ä¹ å·¥å…·</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 15px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 25px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 10px;
            background: #f9f9f9;
        }
        
        .chart-container {
            position: relative;
            height: 500px;
            margin: 15px 0;
        }
        
        .three-container {
            position: relative;
            height: 600px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background: #667eea;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #764ba2;
        }
        
        .info-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .formula {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .prediction-result {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #155724;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .data-table th, .data-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .data-table th {
            background: #667eea;
            color: white;
        }
        
        .feature-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .feature-importance {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ  å¤šå…ƒçº¿æ€§å›å½’å­¦ä¹ å·¥å…·</h1>
            <p>ç”¨æˆ¿ä»·é¢„æµ‹ç†è§£å¤šå…ƒçº¿æ€§å›å½’</p>
        </div>
        
        <div class="section">
            <h2>ğŸ“Š ç¬¬ä¸€æ­¥ï¼šè§‚å¯Ÿå¤šå…ƒæ•°æ®</h2>
            <p>æˆ‘ä»¬æ¥çœ‹çœ‹æˆ¿å­çš„å„ç§ç‰¹å¾å¦‚ä½•å½±å“æˆ¿ä»·ï¼š</p>
            
            <table class="data-table" style="margin: 10px 0;">
                <thead>
                    <tr>
                        <th>æˆ¿å­</th>
                        <th>é¢ç§¯(mÂ²)</th>
                        <th>å§å®¤æ•°</th>
                        <th>æˆ¿ä»·(ä¸‡å…ƒ)</th>
                    </tr>
                </thead>
                <tbody id="dataTable">
                    <tr><td>æˆ¿å­A</td><td>80</td><td>2</td><td>200</td></tr>
                    <tr><td>æˆ¿å­B</td><td>100</td><td>3</td><td>280</td></tr>
                    <tr><td>æˆ¿å­C</td><td>120</td><td>3</td><td>350</td></tr>
                    <tr><td>æˆ¿å­D</td><td>90</td><td>2</td><td>220</td></tr>
                    <tr><td>æˆ¿å­E</td><td>150</td><td>4</td><td>450</td></tr>
                    <tr><td>æˆ¿å­F</td><td>70</td><td>2</td><td>180</td></tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>ğŸ¤” æ€è€ƒï¼šä¸€å…ƒ vs å¤šå…ƒçš„å·®åˆ«</h2>
            <div class="feature-comparison">
                <div class="feature-card">
                    <h3>ğŸ“ˆ ä¸€å…ƒçº¿æ€§å›å½’</h3>
                    <p><strong>åªæœ‰ä¸€ä¸ªç‰¹å¾</strong></p>
                    <p>å…¬å¼ï¼šæˆ¿ä»· = a Ã— é¢ç§¯ + b</p>
                    <p>ç¼ºç‚¹ï¼šåªè€ƒè™‘é¢ç§¯ï¼Œå¿½ç•¥å…¶ä»–é‡è¦å› ç´ </p>
                    <div class="info-panel">
                        <strong>ä¸¾ä¾‹ï¼š</strong>100mÂ²çš„æˆ¿å­ï¼Œä¸€å…ƒå›å½’å¯èƒ½é¢„æµ‹250ä¸‡ï¼Œä½†å®é™…å¯èƒ½å› ä¸ºæˆ¿é¾„å¤ªè€åªå€¼180ä¸‡ï¼
                    </div>
                </div>
                <div class="feature-card">
                    <h3>ğŸ  å¤šå…ƒçº¿æ€§å›å½’</h3>
                    <p><strong>å¤šä¸ªç‰¹å¾ä¸€èµ·è€ƒè™‘</strong></p>
                    <p>å…¬å¼ï¼šæˆ¿ä»· = aâ‚Ã—é¢ç§¯ + aâ‚‚Ã—å§å®¤ + aâ‚ƒÃ—æˆ¿é¾„ + aâ‚„Ã—è·ç¦» + b</p>
                    <p>ä¼˜ç‚¹ï¼šç»¼åˆè€ƒè™‘æ‰€æœ‰å› ç´ ï¼Œé¢„æµ‹æ›´å‡†ç¡®</p>
                    <div class="info-panel">
                        <strong>ä¸¾ä¾‹ï¼š</strong>åŒæ ·çš„100mÂ²æˆ¿å­ï¼Œå¤šå…ƒå›å½’ä¼šåŒæ—¶è€ƒè™‘æˆ¿é¾„ã€è·ç¦»ç­‰å› ç´ ï¼Œç»™å‡ºæ›´å‡†ç¡®çš„180ä¸‡é¢„æµ‹ï¼
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“ˆ ç¬¬äºŒæ­¥ï¼šå¯è§†åŒ–å¤šå…ƒå…³ç³»ï¼ˆ3Dç‰ˆï¼‰</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="toggleDataPoints()" id="showDataBtn" style="background: #dc3545; color: white; font-weight: bold; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                    ğŸ‘ï¸ æ˜¾ç¤º3Dæˆ¿ä»·æ•°æ®
                </button>
                <button onclick="calculateBestFitModel()" style="margin: 5px 0; background: #28a745; font-weight: bold;">ğŸ” è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹</button>
                <button onclick="resetData()" style="margin: 5px 0;">é‡ç½®æ•°æ®</button>
                <button onclick="generateRandomData()" style="margin: 5px 0;">ç”Ÿæˆéšæœºæ•°æ®</button>
                <input type="number" id="newArea" placeholder="é¢ç§¯(mÂ²)" min="50" max="200" step="5" style="margin: 5px 0;">
                <input type="number" id="newRooms" placeholder="å§å®¤æ•°" min="1" max="5" step="1" style="margin: 5px 0;">
                <input type="number" id="newPrice" placeholder="æˆ¿ä»·(ä¸‡å…ƒ)" min="100" max="500" step="10" style="margin: 5px 0;">
                <button onclick="addData()" style="margin: 5px 0;">æ‰‹åŠ¨æ·»åŠ æ•°æ®</button>
                
                <div>
                    <input type="number" id="predArea" placeholder="é¢ç§¯(mÂ²)" min="50" max="200" step="5" style="margin: 5px 0;">
                    <input type="number" id="predRooms" placeholder="å§å®¤æ•°" min="1" max="5" step="1" style="margin: 5px 0;">
                    <button onclick="makePrediction()" style="margin: 5px 0;">é¢„æµ‹æˆ¿ä»·</button>
                </div>
                
                <div id="predictionResult" class="prediction-result" style="margin: 10px 0;">è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°ï¼Œç„¶åç‚¹å‡»"é¢„æµ‹æˆ¿ä»·"æŒ‰é’®</div>
                
                
            </div>
            <div class="three-container" id="threeContainer"></div>
        </div>
        

        
        <div class="section">
            <h2>ğŸ“Š ç‰¹å¾é‡è¦æ€§åˆ†æ</h2>
            <div id="featureImportance" class="feature-importance">
                <p>ğŸ’¡ è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹åï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºæ¯ä¸ªç‰¹å¾å¯¹æˆ¿ä»·çš„å½±å“ç¨‹åº¦ï¼š</p>
                <div id="importanceDetails">ç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŸ¥çœ‹ç‰¹å¾æƒé‡</div>
                <div id="modelAccuracy" style="margin-top: 10px; font-weight: bold; color: #d63384;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ”¢ è®¡ç®—ç»“æœ</h2>
            <div class="formula" id="formulaDisplay" style="font-size: 14px;">
                æ­£åœ¨è®¡ç®—ä¸­...
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ¤– ä¸äººå·¥æ™ºèƒ½çš„å…³ç³»</h2>
            <div style="background: #f8d7da; padding: 15px; border-radius: 8px; border-left: 5px solid #dc3545;">
                <h3>ğŸ§  AIå¦‚ä½•ç”¨å¤šå…ƒçº¿æ€§å›å½’ï¼Ÿ</h3>
                <p><strong>æ·˜å®æ¨èï¼š</strong>æ ¹æ®ä½ çš„å¹´é¾„ã€æ€§åˆ«ã€æµè§ˆå†å²ç­‰å¤šä¸ªç‰¹å¾ï¼Œé¢„æµ‹ä½ å¯èƒ½å–œæ¬¢çš„å•†å“</p>
                <p><strong>æŠ–éŸ³æ¨èï¼š</strong>æ ¹æ®ä½ çš„è§‚çœ‹æ—¶é•¿ã€ç‚¹èµç±»å‹ã€å…³æ³¨ç”¨æˆ·ç­‰å¤šä¸ªç»´åº¦ï¼Œæ¨èä½ å¯èƒ½æ„Ÿå…´è¶£çš„è§†é¢‘</p>
                <p><strong>åŒ»ç–—è¯Šæ–­ï¼š</strong>æ ¹æ®å¹´é¾„ã€è¡€å‹ã€è¡€ç³–ã€èƒ†å›ºé†‡ç­‰å¤šä¸ªæŒ‡æ ‡ï¼Œé¢„æµ‹ç–¾ç—…é£é™©</p>
                
                <h3>ğŸ¯ å¤šå…ƒå›å½’çš„é­”åŠ›</h3>
                <p>ç°å®ä¸–ç•Œçš„é—®é¢˜å¾€å¾€æ¶‰åŠå¤šä¸ªå› ç´ ï¼Œå°±åƒæˆ¿ä»·ä¸ä»…çœ‹é¢ç§¯ï¼Œè¿˜è¦çœ‹åœ°æ®µã€æˆ¿é¾„ç­‰ã€‚å¤šå…ƒçº¿æ€§å›å½’è®©AIèƒ½å¤Ÿåƒäººç±»ä¸“å®¶ä¸€æ ·ï¼Œç»¼åˆè€ƒè™‘å„ç§å› ç´ åšå‡ºæ›´å‡†ç¡®çš„åˆ¤æ–­ï¼</p>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let scatterPoints = [];
        let regressionPlane;
        let dataPointsVisible = false;
        let modelCalculated = false;
        
        let houseData = [
            {area: 80, rooms: 2, price: 200, name: 'æˆ¿å­A'},
            {area: 100, rooms: 3, price: 280, name: 'æˆ¿å­B'},
            {area: 120, rooms: 3, price: 350, name: 'æˆ¿å­C'},
            {area: 90, rooms: 2, price: 220, name: 'æˆ¿å­D'},
            {area: 150, rooms: 4, price: 450, name: 'æˆ¿å­E'},
            {area: 70, rooms: 2, price: 180, name: 'æˆ¿å­F'}
        ];
        
        function init3DScene() {
            const container = document.getElementById('threeContainer');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            // åˆ›å»ºç›¸æœº - è°ƒæ•´è§†è§’ä»¥æ›´å¥½åœ°è§‚å¯Ÿåæ ‡ç³»å’Œå›å½’å¹³é¢
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            // è·å–æ•°æ®èŒƒå›´æ¥è°ƒæ•´ç›¸æœºä½ç½®
            const areas = houseData.map(d => d.area);
            const prices = houseData.map(d => d.price);
            const roomDataArray = houseData.map(d => d.rooms);
            
            const maxArea = Math.max(...areas);
            const maxPrice = Math.max(...prices);
            const maxRooms = Math.max(...roomDataArray);
            
            // æ ¹æ®æ•°æ®èŒƒå›´è°ƒæ•´ç›¸æœºä½ç½®
            const centerX = maxArea / 2;
            const centerY = maxPrice / 2;
            const centerZ = maxRooms / 2;
            
            camera.position.set(centerX + 50, centerY + 50, centerZ + 50);
            camera.lookAt(centerX, centerY, centerZ);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // æ·»åŠ æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.target.set(centerX, centerY, centerZ); // è®¾ç½®æ§åˆ¶ä¸­å¿ƒç‚¹
            
            // åˆ›å»ºè‡ªå®šä¹‰åæ ‡ç³»
            createCustomAxes();
            
            // æ·»åŠ ç½‘æ ¼ - åœ¨XZå¹³é¢ä¸Šï¼Œæ ¹æ®æ•°æ®èŒƒå›´è°ƒæ•´å¤§å°
            const gridSize = Math.max(maxArea, maxPrice, maxRooms * 10) + 20;
            const gridHelper = new THREE.GridHelper(gridSize, 20, 0xcccccc, 0xcccccc);
            gridHelper.position.set(centerX, 0, centerZ);
            scene.add(gridHelper);
            
            // æ·»åŠ åæ ‡è½´æ ‡ç­¾å’Œåˆ»åº¦
            createAxisLabels();
            
            // æ·»åŠ å›¾ä¾‹è¯´æ˜
            createLegend();
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(100, 100, 100);
            scene.add(directionalLight);
            
            animate();
        }
        
        function createCustomAxes() {
            // åˆ›å»ºè‡ªå®šä¹‰åæ ‡ç³» - å·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼Œä½¿ç”¨åŸå§‹æ•°æ®å€¼
            const axesGroup = new THREE.Group();
            
            // è·å–æ•°æ®èŒƒå›´
            const areas = houseData.map(d => d.area);
            const prices = houseData.map(d => d.price);
            const roomDataArray = houseData.map(d => d.rooms);
            
            const maxArea = Math.max(...areas);
            const maxPrice = Math.max(...prices);
            const maxRooms = Math.max(...roomDataArray);
            
            // Xè½´ï¼ˆé¢ç§¯ï¼‰- çº¢è‰²ï¼Œå‘å³ï¼Œä½¿ç”¨åŸå§‹é¢ç§¯å€¼
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(maxArea + 20, 0, 0)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            axesGroup.add(xAxis);
            
            // Yè½´ï¼ˆä»·æ ¼ï¼‰- ç»¿è‰²ï¼Œå‘ä¸Šï¼Œä½¿ç”¨åŸå§‹ä»·æ ¼å€¼
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, maxPrice + 50, 0)
            ]);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            axesGroup.add(yAxis);
            
            // Zè½´ï¼ˆå§å®¤æ•°ï¼‰- è“è‰²ï¼Œå‘å†…ï¼Œä½¿ç”¨åŸå§‹å§å®¤æ•°å€¼çš„50å€ï¼ˆè°ƒæ•´æ¯”ä¾‹ï¼‰
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, (maxRooms + 1) * 50)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            axesGroup.add(zAxis);
            
            // æ·»åŠ åˆ»åº¦æ ‡è®° - ä½¿ç”¨å®é™…æ•°æ®å€¼
            // Xè½´åˆ»åº¦ï¼ˆé¢ç§¯ï¼‰
            for (let i = 0; i <= Math.ceil(maxArea / 20); i++) {
                const x = i * 20;
                if (x <= maxArea + 20) {
                    const xTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, -2, 0),
                        new THREE.Vector3(x, 2, 0)
                    ]);
                    const xTick = new THREE.Line(xTickGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
                    axesGroup.add(xTick);
                }
            }
            
            // Yè½´åˆ»åº¦ï¼ˆä»·æ ¼ï¼‰
            for (let i = 0; i <= Math.ceil(maxPrice / 50); i++) {
                const y = i * 50;
                if (y <= maxPrice + 50) {
                    const yTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(-2, y, 0),
                        new THREE.Vector3(2, y, 0)
                    ]);
                    const yTick = new THREE.Line(yTickGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    axesGroup.add(yTick);
                }
            }
            
            // Zè½´åˆ»åº¦ï¼ˆå§å®¤æ•°ï¼‰- æ”¾å¤§50å€
            for (let i = 0; i <= maxRooms + 1; i++) {
                const z = i * 50;
                const zTickGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -2, z),
                    new THREE.Vector3(0, 2, z)
                ]);
                const zTick = new THREE.Line(zTickGeometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                axesGroup.add(zTick);
            }
            
            scene.add(axesGroup);
        }
        
        function createAxisLabels() {
            // åˆ›å»ºæ–‡å­—ç²¾çµå‡½æ•°
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(15, 4, 1);
                
                return sprite;
            }
            
            // åˆ›å»ºåˆ»åº¦æ ‡ç­¾å‡½æ•°
            function createTickLabel(text, color = '#666666') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 32;
                
                context.font = '12px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 64, 16);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(8, 2, 1);
                
                return sprite;
            }
            
            // è·å–æ•°æ®èŒƒå›´
            const areas = houseData.map(d => d.area);
            const prices = houseData.map(d => d.price);
            const roomDataArray = houseData.map(d => d.rooms);
            
            const maxArea = Math.max(...areas);
            const maxPrice = Math.max(...prices);
            const maxRooms = Math.max(...roomDataArray);
            
            // ä¸»åæ ‡è½´æ ‡ç­¾
            const xLabel = createTextSprite('é¢ç§¯ (mÂ²)', '#ff0000');
            xLabel.position.set(maxArea / 2, -8, 0);
            scene.add(xLabel);
            
            const yLabel = createTextSprite('ä»·æ ¼ (ä¸‡å…ƒ)', '#00ff00');
            yLabel.position.set(-8, maxPrice / 2, 0);
            scene.add(yLabel);
            
            const zLabel = createTextSprite('å§å®¤æ•°', '#0000ff');
            zLabel.position.set(0, -8, (maxRooms / 2) * 50);
            scene.add(zLabel);
            
            // æ·»åŠ åˆ»åº¦æ ‡ç­¾ - ä½¿ç”¨å®é™…æ•°æ®å€¼
            // Xè½´åˆ»åº¦æ ‡ç­¾ï¼ˆé¢ç§¯ï¼‰
            for (let i = 0; i <= Math.ceil(maxArea / 20); i++) {
                const value = i * 20;
                if (value <= maxArea + 20) {
                    const xTickLabel = createTickLabel(value.toString(), '#ff0000');
                    xTickLabel.position.set(value, -5, 0);
                    scene.add(xTickLabel);
                }
            }
            
            // Yè½´åˆ»åº¦æ ‡ç­¾ï¼ˆä»·æ ¼ï¼‰
            for (let i = 0; i <= Math.ceil(maxPrice / 50); i++) {
                const value = i * 50;
                if (value <= maxPrice + 50) {
                    const yTickLabel = createTickLabel(value.toString(), '#00ff00');
                    yTickLabel.position.set(-5, value, 0);
                    scene.add(yTickLabel);
                }
            }
            
            // Zè½´åˆ»åº¦æ ‡ç­¾ï¼ˆå§å®¤æ•°ï¼‰- æ”¾å¤§50å€
            for (let i = 0; i <= maxRooms + 1; i++) {
                const zTickLabel = createTickLabel(i.toString(), '#0000ff');
                zTickLabel.position.set(0, -5, i * 50);
                scene.add(zTickLabel);
            }
        }
        
        function createLegend() {
            // åˆ›å»ºå›¾ä¾‹HTMLå…ƒç´ 
            const legendHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 12px; z-index: 100; max-width: 280px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">ğŸ“Š 3Dåæ ‡ç³»è¯´æ˜</h4>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border-radius: 50%; margin-right: 8px;"></span>
                        <span>çº¢è‰²åœ†ç‚¹ = å®é™…æˆ¿ä»·æ•°æ®</span>
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: rgba(33, 150, 243, 0.4); margin-right: 8px;"></span>
                        <span>è“è‰²å¹³é¢ = å¤šå…ƒå›å½’é¢„æµ‹æ¨¡å‹</span>
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #00ff00; border-radius: 50%; margin-right: 8px;"></span>
                        <span>ç»¿è‰²åœ†ç‚¹ = é¢„æµ‹æˆ¿ä»·</span>
                    </div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>åæ ‡ç³»ï¼ˆå·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼‰ï¼š</strong></div>
                    <div style="margin: 3px 0; color: #ff0000;">ğŸ“ Xè½´ï¼ˆçº¢è‰²ï¼‰ï¼šå‘å³ = é¢ç§¯å¢åŠ  (70-150mÂ²)</div>
                    <div style="margin: 3px 0; color: #00ff00;">ğŸ’° Yè½´ï¼ˆç»¿è‰²ï¼‰ï¼šå‘ä¸Š = ä»·æ ¼å¢åŠ  (180-450ä¸‡å…ƒ)</div>
                    <div style="margin: 3px 0; color: #0000ff;">ğŸ  Zè½´ï¼ˆè“è‰²ï¼‰ï¼šå‘å†… = å§å®¤æ•°å¢åŠ  (2-4é—´)</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>åæ ‡æ˜ å°„ï¼š</strong></div>
                    <div style="margin: 3px 0;">é¢ç§¯ï¼šç›´æ¥ä½¿ç”¨åŸå§‹å€¼ (mÂ²)</div>
                    <div style="margin: 3px 0;">ä»·æ ¼ï¼šç›´æ¥ä½¿ç”¨åŸå§‹å€¼ (ä¸‡å…ƒ)</div>
                    <div style="margin: 3px 0;">å§å®¤æ•°ï¼šåŸå§‹å€¼Ã—50 (é—´)</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0; color: #666;">
                        ğŸ’¡ <em>é¼ æ ‡æ‹–æ‹½æ—‹è½¬è§†è§’ï¼Œæ»šè½®ç¼©æ”¾</em>
                    </div>
                </div>
            `;
            
            // æ·»åŠ å›¾ä¾‹åˆ°å®¹å™¨
            const container = document.getElementById('threeContainer');
            const legendDiv = document.createElement('div');
            legendDiv.innerHTML = legendHTML;
            container.style.position = 'relative';
            container.appendChild(legendDiv.firstElementChild);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function toggleDataPoints() {
            if (!dataPointsVisible) {
                show3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = 'ğŸ™ˆ éšè—3Dæˆ¿ä»·æ•°æ®';
                document.getElementById('showDataBtn').style.background = '#6c757d';
                dataPointsVisible = true;
            } else {
                hide3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = 'ğŸ‘ï¸ æ˜¾ç¤º3Dæˆ¿ä»·æ•°æ®';
                document.getElementById('showDataBtn').style.background = '#dc3545';
                dataPointsVisible = false;
            }
        }
        
        function show3DDataPoints() {
            // æ¸…é™¤ç°æœ‰æ•°æ®ç‚¹
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // æ·»åŠ æ–°çš„æ•°æ®ç‚¹ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®å€¼
            houseData.forEach((house, index) => {
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x330000
                });
                const sphere = new THREE.Mesh(geometry, material);
                
                // ç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®å€¼ï¼Œä¸è¿›è¡Œæ˜ å°„
                sphere.position.set(
                    house.area,      // é¢ç§¯ç›´æ¥ä½¿ç”¨åŸå§‹å€¼
                    house.price,     // ä»·æ ¼ç›´æ¥ä½¿ç”¨åŸå§‹å€¼
                    house.rooms * 50 // å§å®¤æ•°æ”¾å¤§50å€
                );
                
                // æ·»åŠ æ•°æ®æ ‡ç­¾ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
                const label = createDataLabel(`${house.name}\n${house.area}mÂ², ${house.price}ä¸‡`);
                label.position.set(house.area + 3, house.price, house.rooms * 50);
                scene.add(label);
                
                scene.add(sphere);
                scatterPoints.push(sphere);
            });
            
            // å°†æ•°æ®ç‚¹åˆ†ç»„å‘½åï¼Œä¾¿äºç®¡ç†
            const dataGroup = new THREE.Group();
            dataGroup.name = 'dataPoints';
            scatterPoints.forEach(point => dataGroup.add(point));
            scene.add(dataGroup);
        }
        
        function createDataLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 40;
            
            // ç»˜åˆ¶èƒŒæ™¯
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            context.fillRect(0, 0, 200, 40);
            context.strokeStyle = '#666';
            context.lineWidth = 1;
            context.strokeRect(0, 0, 200, 40);
            
            // ç»˜åˆ¶æ–‡å­—
            context.font = 'bold 10px Arial';
            context.fillStyle = '#333';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            const lines = text.split('\n');
            lines.forEach((line, index) => {
                context.fillText(line, 100, 10 + index * 12);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 1.6, 1);
            
            return sprite;
        }
        
        function hide3DDataPoints() {
            // æ¸…é™¤æ•°æ®ç‚¹
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾
            if (scene) {
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
        }
        


        function calculateMultipleRegression() {
            // äºŒå…ƒçº¿æ€§å›å½’è®¡ç®—ï¼ˆé¢ç§¯å’Œå§å®¤æ•°ï¼‰
            const n = houseData.length;
            
            // è®¡ç®—å‡å€¼
            const meanArea = houseData.reduce((sum, d) => sum + d.area, 0) / n;
            const meanRooms = houseData.reduce((sum, d) => sum + d.rooms, 0) / n;
            const meanPrice = houseData.reduce((sum, d) => sum + d.price, 0) / n;
            
            // è®¡ç®—åæ–¹å·®å’Œæ–¹å·®
            let covAreaPrice = 0, covRoomsPrice = 0, varArea = 0, varRooms = 0, covAreaRooms = 0;
            
            houseData.forEach(d => {
                covAreaPrice += (d.area - meanArea) * (d.price - meanPrice);
                covRoomsPrice += (d.rooms - meanRooms) * (d.price - meanPrice);
                varArea += (d.area - meanArea) ** 2;
                varRooms += (d.rooms - meanRooms) ** 2;
                covAreaRooms += (d.area - meanArea) * (d.rooms - meanRooms);
            });
            
            // è§£äºŒå…ƒçº¿æ€§æ–¹ç¨‹ç»„
            const denominator = varArea * varRooms - covAreaRooms ** 2;
            const a1 = (covAreaPrice * varRooms - covRoomsPrice * covAreaRooms) / denominator;
            const a2 = (covRoomsPrice * varArea - covAreaPrice * covAreaRooms) / denominator;
            const b = meanPrice - a1 * meanArea - a2 * meanRooms;
            
            return {a1, a2, b};
        }
        
        function calculateBestFitModel() {
            if (!dataPointsVisible) {
                alert('è¯·å…ˆç‚¹å‡»"æ˜¾ç¤ºæˆ¿ä»·æ•°æ®"æŒ‰é’®ï¼');
                return;
            }
            
            if (houseData.length < 3) {
                alert('éœ€è¦è‡³å°‘3ä¸ªæ•°æ®ç‚¹æ‰èƒ½è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹ï¼');
                return;
            }
            
            document.getElementById('formulaDisplay').innerHTML = 
                'ğŸ§® æ­£åœ¨ç”¨å¤šå…ƒçº¿æ€§å›å½’è®¡ç®—æœ€ä½³æ¨¡å‹...';
            
            const coeffs = calculateMultipleRegression();
            
            // ç›´æ¥æ˜¾ç¤º3Då›å½’å¹³é¢ï¼ˆç§»é™¤Chart.jsä¾èµ–ï¼‰
            setTimeout(() => {
                // æ˜¾ç¤ºäºŒå…ƒå›å½’å…¬å¼
                document.getElementById('formulaDisplay').innerHTML = 
                    `ğŸ“Š äºŒå…ƒçº¿æ€§å›å½’ç»“æœï¼š<br>æˆ¿ä»· = ${coeffs.a1.toFixed(1)}Ã—é¢ç§¯ + ${coeffs.a2.toFixed(1)}Ã—å§å®¤æ•° + ${coeffs.b.toFixed(1)}<br><br>ğŸ¯ è¿™ä¸ªæ¨¡å‹ç»¼åˆè€ƒè™‘äº†é¢ç§¯å’Œå§å®¤æ•°ï¼`;
                
                // æ˜¾ç¤ºç‰¹å¾é‡è¦æ€§ï¼ˆäºŒç»´ï¼‰
                document.getElementById('importanceDetails').innerHTML = 
                    `<strong>ğŸ† ç‰¹å¾é‡è¦æ€§ï¼š</strong><br>
                    1. é¢ç§¯ï¼šæ¯å¢åŠ 1mÂ²ï¼Œæˆ¿ä»·+${coeffs.a1.toFixed(1)}ä¸‡å…ƒ<br>
                    2. å§å®¤æ•°ï¼šæ¯å¤š1é—´ï¼Œæˆ¿ä»·+${coeffs.a2.toFixed(1)}ä¸‡å…ƒ`;
                
                document.getElementById('modelAccuracy').innerHTML = 
                    `ğŸ“ˆ 3Dæ¨¡å‹å±•ç¤ºï¼šçº¢è‰²ç‚¹=å®é™…æ•°æ®ï¼Œè“è‰²å¹³é¢=å›å½’é¢„æµ‹`;
                
                // æ˜¾ç¤º3Då›å½’å¹³é¢
                showRegressionPlane(coeffs);
                
                modelCalculated = true;
            }, 500);
        }


        
        function makePrediction() {
            console.log('=== å¼€å§‹é¢„æµ‹ ===');
            console.log('æ¨¡å‹æ˜¯å¦å·²è®¡ç®—:', modelCalculated);
            
            if (!modelCalculated) {
                console.log('âš ï¸ æ¨¡å‹æœªè®¡ç®—ï¼Œå°è¯•è‡ªåŠ¨è®¡ç®—æ¨¡å‹...');
                // å°è¯•è‡ªåŠ¨è®¡ç®—æ¨¡å‹
                try {
                    const coeffs = calculateMultipleRegression();
                    if (coeffs && coeffs.a1 !== undefined) {
                        console.log('âœ… è‡ªåŠ¨è®¡ç®—æ¨¡å‹æˆåŠŸ');
                        modelCalculated = true;
                    } else {
                        alert('è¯·å…ˆç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŒ‰é’®ï¼');
                        return;
                    }
                } catch (error) {
                    console.log('âŒ è‡ªåŠ¨è®¡ç®—æ¨¡å‹å¤±è´¥:', error);
                    alert('è¯·å…ˆç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŒ‰é’®ï¼');
                    return;
                }
            }
            
            const area = parseFloat(document.getElementById('predArea').value);
            const rooms = parseFloat(document.getElementById('predRooms').value);
            
            console.log('è¾“å…¥å‚æ•°:', {area, rooms});
            
            if (isNaN(area) || isNaN(rooms)) {
                alert('è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°ï¼');
                return;
            }
            
            // æ¸…é™¤ä¹‹å‰çš„é¢„æµ‹ç‚¹
            if (scene) {
                const oldPredictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                oldPredictionPoints.forEach(point => scene.remove(point));
                
                // æ¸…é™¤é¢„æµ‹ç‚¹æ ‡ç­¾
                const oldPredictionLabels = scene.children.filter(obj => 
                    obj.type === 'Sprite' && obj.userData && obj.userData.isPrediction
                );
                oldPredictionLabels.forEach(label => scene.remove(label));
                
                // æ¸…é™¤é¢„æµ‹ç‚¹è¾…åŠ©çº¿
                const oldPredictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                oldPredictionHelpers.forEach(helper => scene.remove(helper));
            }
            
            // ä½¿ç”¨äºŒå…ƒå›å½’ç³»æ•°è¿›è¡Œé¢„æµ‹
            const coeffs = calculateMultipleRegression();
            const predictedPrice = coeffs.a1 * area + coeffs.a2 * rooms + coeffs.b;
            

            
            // åœ¨3Dåœºæ™¯ä¸­æ˜¾ç¤ºé¢„æµ‹ç‚¹
            const predictionGeometry = new THREE.SphereGeometry(2, 16, 16); // å‡å°é¢„æµ‹ç‚¹å¤§å°
            const predictionMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x003300,
                transparent: true,
                opacity: 0.8 // å¢åŠ é€æ˜åº¦
            });
            const predictionSphere = new THREE.Mesh(predictionGeometry, predictionMaterial);
            
            // ç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®å€¼ï¼Œä¸è¿›è¡Œæ˜ å°„
            const predictionX = area;           // é¢ç§¯ç›´æ¥ä½¿ç”¨åŸå§‹å€¼
            const predictionY = predictedPrice; // ä»·æ ¼ç›´æ¥ä½¿ç”¨åŸå§‹å€¼
            const predictionZ = rooms * 50;     // å§å®¤æ•°æ”¾å¤§50å€
            
            predictionSphere.position.set(predictionX, predictionY, predictionZ);
            
            // æ·»åŠ é¢„æµ‹ç‚¹æ ‡ç­¾
            const predictionLabel = createDataLabel(`é¢„æµ‹\n${area}mÂ², ${predictedPrice.toFixed(1)}ä¸‡`);
            predictionLabel.position.set(predictionX + 5, predictionY, predictionZ);
            predictionLabel.userData = { isPrediction: true }; // æ·»åŠ æ ‡è¯†
            scene.add(predictionLabel);
            scene.add(predictionSphere);
            
            // æ·»åŠ è¾…åŠ©çº¿ï¼Œä»é¢„æµ‹ç‚¹å‚ç›´å‘ä¸‹åˆ°å¹³é¢
            const helperLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(predictionX, predictionY, predictionZ),
                new THREE.Vector3(predictionX, predictionY - 10, predictionZ) // å‘ä¸‹å»¶ä¼¸10ä¸ªå•ä½
            ]);
            const helperLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                linewidth: 2,
                transparent: true,
                opacity: 0.6
            });
            const helperLine = new THREE.Line(helperLineGeometry, helperLineMaterial);
            helperLine.userData = { isPrediction: true };
            scene.add(helperLine);
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯
            console.log('=== é¢„æµ‹ç‚¹ä¿¡æ¯ ===');
            console.log('é¢„æµ‹ç‚¹ä½ç½®:', {x: predictionX, y: predictionY, z: predictionZ});
            console.log('é¢„æµ‹ç»“æœ:', {area, rooms, predictedPrice});
            
            // éªŒè¯é¢„æµ‹ç‚¹æ˜¯å¦åœ¨å›å½’å¹³é¢ä¸Š
            // ä½¿ç”¨ä¸å¹³é¢ç›¸åŒçš„æ•°å­¦åŸç†
            const expectedY = coeffs.a1 * area + coeffs.a2 * rooms + coeffs.b;
            const deviation = Math.abs(predictionY - expectedY);
            
            // éªŒè¯æ•°å­¦è®¡ç®—
            console.log('=== æ•°å­¦éªŒè¯ ===');
            console.log('å›å½’æ–¹ç¨‹: ä»·æ ¼ =', coeffs.a1, 'Ã—', area, '+', coeffs.a2, 'Ã—', rooms, '+', coeffs.b);
            console.log('é¢„æµ‹ä»·æ ¼:', predictedPrice);
            console.log('3Dåæ ‡ç³»æ˜ å°„:');
            console.log('- Xè½´ (é¢ç§¯):', area);
            console.log('- Yè½´ (ä»·æ ¼):', predictedPrice);
            console.log('- Zè½´ (å§å®¤æ•°):', rooms * 50);
            
            console.log('é¢„æµ‹ç‚¹éªŒè¯:');
            console.log('- é¢„æµ‹ç‚¹åæ ‡:', {x: predictionX, y: predictionY, z: predictionZ});
            console.log('- å›å½’å¹³é¢åœ¨è¯¥ç‚¹çš„Yå€¼:', expectedY);
            console.log('- åå·®:', deviation);
            console.log('- é¢„æµ‹ç‚¹æ˜¯å¦åœ¨å¹³é¢ä¸Š:', deviation < 0.1 ? 'æ˜¯' : 'å¦');
            
            // éªŒè¯é¢„æµ‹ç‚¹æ˜¯å¦åœ¨å¹³é¢è¦†ç›–èŒƒå›´å†…
            const roomDataArray = houseData.map(d => d.rooms);
            const minRooms = Math.min(...roomDataArray);
            const maxRooms = Math.max(...roomDataArray);
            
            const planeCenterZ = (minRooms + maxRooms) / 2 * 50; // å¹³é¢ä¸­å¿ƒZåæ ‡ï¼Œæ”¾å¤§50å€
            const planeDepth = (maxRooms - minRooms) * 150; // å¹³é¢æ·±åº¦ï¼Œå¯¹åº”Zè½´æ”¾å¤§50å€
            const inPlaneRange = predictionZ >= planeCenterZ - planeDepth/2 && predictionZ <= planeCenterZ + planeDepth/2;
            console.log('- é¢„æµ‹ç‚¹æ˜¯å¦åœ¨å¹³é¢è¦†ç›–èŒƒå›´å†…:', inPlaneRange ? 'æ˜¯' : 'å¦');
            console.log('- å¹³é¢Zè½´èŒƒå›´:', {min: planeCenterZ - planeDepth/2, max: planeCenterZ + planeDepth/2});
            console.log('- é¢„æµ‹ç‚¹Zåæ ‡:', predictionZ);
            console.log('- å¹³é¢ä¸­å¿ƒZåæ ‡:', planeCenterZ);
            console.log('- å¹³é¢æ·±åº¦:', planeDepth);
            
            if (deviation > 0.1) {
                console.log('âš ï¸ è­¦å‘Šï¼šé¢„æµ‹ç‚¹åç¦»å›å½’å¹³é¢ï¼Œå¯èƒ½éœ€è¦æ£€æŸ¥å¹³é¢è®¡ç®—');
            }
            if (!inPlaneRange) {
                console.log('âš ï¸ è­¦å‘Šï¼šé¢„æµ‹ç‚¹è¶…å‡ºå¹³é¢è¦†ç›–èŒƒå›´ï¼Œå¯èƒ½çœ‹ä¸åˆ°å¹³é¢');
            }
            
            // ç²¾ç¡®éªŒè¯é¢„æµ‹ç‚¹æ˜¯å¦åœ¨å¹³é¢ä¸Š
            console.log('=== ç²¾ç¡®å¹³é¢éªŒè¯ ===');
            
            // è·å–å¹³é¢ä¿¡æ¯
            const plane = scene.getObjectByName('regressionPlane');
            if (plane) {
                const planeCenterX = plane.position.x;
                const planeCenterY = plane.position.y;
                const planeCenterZ = plane.position.z;
                
                // è®¡ç®—é¢„æµ‹ç‚¹åœ¨å¹³é¢åæ ‡ç³»ä¸­çš„ä½ç½®
                const relativeX = predictionX - planeCenterX;
                const relativeY = predictionY - planeCenterY;
                const relativeZ = predictionZ - planeCenterZ;
                
                // æ ¹æ®å¹³é¢æ—‹è½¬è®¡ç®—é¢„æµ‹ç‚¹åº”è¯¥åœ¨çš„Yåæ ‡
                const expectedYOnPlane = planeCenterY + 
                    relativeX * Math.tan(plane.rotation.z) + 
                    relativeZ * Math.tan(plane.rotation.x);
                
                const planeDeviation = Math.abs(predictionY - expectedYOnPlane);
                console.log('å¹³é¢å‡ ä½•éªŒè¯:');
                console.log('- å¹³é¢ä¸­å¿ƒä½ç½®:', {x: planeCenterX, y: planeCenterY, z: planeCenterZ});
                console.log('- é¢„æµ‹ç‚¹ç›¸å¯¹å¹³é¢ä¸­å¿ƒ:', {x: relativeX, y: relativeY, z: relativeZ});
                console.log('- å¹³é¢æ—‹è½¬è§’åº¦:', {x: plane.rotation.x, z: plane.rotation.z});
                console.log('- é¢„æµ‹ç‚¹Yåæ ‡:', predictionY);
                console.log('- å¹³é¢ä¸Šå¯¹åº”Yåæ ‡:', expectedYOnPlane);
                console.log('- å‡ ä½•åå·®:', planeDeviation);
                console.log('- é¢„æµ‹ç‚¹æ˜¯å¦åœ¨å‡ ä½•å¹³é¢ä¸Š:', planeDeviation < 0.1 ? 'æ˜¯' : 'å¦');
            } else {
                console.log('âš ï¸ è­¦å‘Šï¼šæ‰¾ä¸åˆ°å›å½’å¹³é¢ï¼Œæ— æ³•è¿›è¡Œå‡ ä½•éªŒè¯');
            }
            
            // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
            const predictionDiv = document.getElementById('predictionResult');
            console.log('=== é¢„æµ‹ç»“æœæ˜¾ç¤º ===');
            console.log('é¢„æµ‹ç»“æœåŒºåŸŸ:', predictionDiv);
            if (predictionDiv) {
                const resultText = `ğŸ¯ é¢„æµ‹ç»“æœï¼šè¿™å¥—æˆ¿å­çš„ä»·æ ¼å¤§çº¦æ˜¯${predictedPrice.toFixed(1)}ä¸‡å…ƒ`;
                predictionDiv.innerHTML = resultText;
                console.log('è®¾ç½®é¢„æµ‹ç»“æœæ–‡æœ¬:', resultText);
                console.log('é¢„æµ‹ç»“æœåŒºåŸŸå†…å®¹:', predictionDiv.innerHTML);
            } else {
                console.log('âš ï¸ è­¦å‘Šï¼šæ‰¾ä¸åˆ°é¢„æµ‹ç»“æœåŒºåŸŸ');
            }
        }

        function addData() {
            const area = parseFloat(document.getElementById('newArea').value);
            const rooms = parseFloat(document.getElementById('newRooms').value);
            const price = parseFloat(document.getElementById('newPrice').value);
            
            if (isNaN(area) || isNaN(rooms) || isNaN(price)) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—ï¼');
                return;
            }
            
            houseData.push({area, rooms, price, name: 'æ–°æˆ¿å­'});
            
            // æ›´æ–°è¡¨æ ¼
            const tbody = document.getElementById('dataTable');
            const row = tbody.insertRow();
            row.innerHTML = `<td>æ–°æˆ¿å­</td><td>${area}</td><td>${rooms}</td><td>${price}</td>`;
            
            // æ¸…é™¤3Dåœºæ™¯ä¸­çš„æ‰€æœ‰å…ƒç´ 
            if (scene) {
                // æ¸…é™¤æ•°æ®ç‚¹
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // æ¸…é™¤å›å½’å¹³é¢
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // æ¸…é™¤å›å½’å¹³é¢è¾¹æ¡†
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // æ¸…é™¤é¢„æµ‹ç‚¹
                const predictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                predictionPoints.forEach(point => scene.remove(point));
                
                // æ¸…é™¤é¢„æµ‹ç‚¹è¾…åŠ©çº¿
                const predictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                predictionHelpers.forEach(helper => scene.remove(helper));
                
                // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆé€šè¿‡ç±»å‹è¿‡æ»¤ï¼‰
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = 'å·²æ·»åŠ æ–°æ•°æ®ï¼è¯·é‡æ–°è®¡ç®—æ¨¡å‹';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 'è¯·è¾“å…¥æˆ¿å­ç‰¹å¾è¿›è¡Œé¢„æµ‹';
            }
        }

        function resetData() {
            houseData = [
                {area: 80, rooms: 2, price: 200, name: 'æˆ¿å­A'},
                {area: 100, rooms: 3, price: 280, name: 'æˆ¿å­B'},
                {area: 120, rooms: 3, price: 350, name: 'æˆ¿å­C'},
                {area: 90, rooms: 2, price: 220, name: 'æˆ¿å­D'},
                {area: 150, rooms: 4, price: 450, name: 'æˆ¿å­E'},
                {area: 70, rooms: 2, price: 180, name: 'æˆ¿å­F'}
            ];
            
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = `
                <tr><td>æˆ¿å­A</td><td>80</td><td>2</td><td>200</td></tr>
                <tr><td>æˆ¿å­B</td><td>100</td><td>3</td><td>280</td></tr>
                <tr><td>æˆ¿å­C</td><td>120</td><td>3</td><td>350</td></tr>
                <tr><td>æˆ¿å­D</td><td>90</td><td>2</td><td>220</td></tr>
                <tr><td>æˆ¿å­E</td><td>150</td><td>4</td><td>450</td></tr>
                <tr><td>æˆ¿å­F</td><td>70</td><td>2</td><td>180</td></tr>
            `;
            
            // æ¸…é™¤3Dåœºæ™¯ä¸­çš„æ‰€æœ‰å…ƒç´ 
            if (scene) {
                // æ¸…é™¤æ•°æ®ç‚¹
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // æ¸…é™¤å›å½’å¹³é¢
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // æ¸…é™¤å›å½’å¹³é¢è¾¹æ¡†
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // æ¸…é™¤é¢„æµ‹ç‚¹
                const predictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                predictionPoints.forEach(point => scene.remove(point));
                
                // æ¸…é™¤é¢„æµ‹ç‚¹è¾…åŠ©çº¿
                const predictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                predictionHelpers.forEach(helper => scene.remove(helper));
                
                // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆé€šè¿‡ç±»å‹è¿‡æ»¤ï¼‰
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            dataPointsVisible = false;
            modelCalculated = false;
            
            document.getElementById('showDataBtn').innerHTML = 'ğŸ‘ï¸ æ˜¾ç¤º3Dæˆ¿ä»·æ•°æ®';
            document.getElementById('showDataBtn').style.background = '#dc3545';
            document.getElementById('formulaDisplay').innerHTML = 'æ­£åœ¨è®¡ç®—ä¸­...';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 'è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°è¿›è¡Œé¢„æµ‹';
            }
            document.getElementById('importanceDetails').innerHTML = 'ç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŸ¥çœ‹ç‰¹å¾æƒé‡';
            document.getElementById('modelAccuracy').innerHTML = '';
        }

        function generateRandomData() {
            houseData = [];
            const names = ['æˆ¿å­G', 'æˆ¿å­H', 'æˆ¿å­I', 'æˆ¿å­J', 'æˆ¿å­K', 'æˆ¿å­L'];
            
            // ç”Ÿæˆæ›´å¤šæ ·åŒ–çš„éšæœºæ•°æ®
            console.log('=== ç”Ÿæˆéšæœºæ•°æ® ===');
            
            // ä¸ºæ•´ä¸ªæ•°æ®é›†é€‰æ‹©ä¸€ç»„å›ºå®šçš„ç³»æ•°ï¼Œç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§
            const areaCoeff = (Math.random() * 3) + 2; // 2-5ï¼Œé¢ç§¯å¯¹ä»·æ ¼çš„æ­£å‘å½±å“
            const roomCoeff = (Math.random() * 40) + 20; // 20-60ï¼Œå§å®¤æ•°å¯¹ä»·æ ¼çš„æ­£å‘å½±å“
            const basePrice = (Math.random() * 150) + 100; // 100-250ï¼ŒåŸºç¡€ä»·æ ¼
            
            console.log(`ä½¿ç”¨ç³»æ•°: é¢ç§¯${areaCoeff.toFixed(1)}, å§å®¤${roomCoeff.toFixed(1)}, åŸºç¡€ä»·æ ¼${basePrice.toFixed(1)}`);
            
            for (let i = 0; i < 6; i++) {
                const area = Math.floor(Math.random() * 100) + 60; // 60-160
                const rooms = Math.floor(Math.random() * 3) + 2; // 2-4
                
                // æ·»åŠ éšæœºå™ªå£°ï¼Œä½†ä¿æŒæ­£ç³»æ•°
                const noise = (Math.random() - 0.5) * 80; // -40åˆ°40çš„éšæœºå™ªå£°
                
                const price = Math.floor(area * areaCoeff + rooms * roomCoeff + basePrice + noise);
                
                console.log(`æˆ¿å­${names[i]}: é¢ç§¯${area}mÂ², å§å®¤${rooms}é—´, ä»·æ ¼${price}ä¸‡`);
                
                houseData.push({area, rooms, price, name: names[i]});
            }
            
            // æ›´æ–°è¡¨æ ¼
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            houseData.forEach(house => {
                const row = tbody.insertRow();
                row.innerHTML = `<td>${house.name}</td><td>${house.area}</td><td>${house.rooms}</td><td>${house.price}</td>`;
            });
            
            // æ¸…é™¤3Dåœºæ™¯ä¸­çš„æ‰€æœ‰å…ƒç´ 
            if (scene) {
                // æ¸…é™¤æ•°æ®ç‚¹
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // æ¸…é™¤å›å½’å¹³é¢
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // æ¸…é™¤å›å½’å¹³é¢è¾¹æ¡†
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // æ¸…é™¤é¢„æµ‹ç‚¹
                const predictionPoints = scene.children.filter(obj => 
                    obj.material && obj.material.color && obj.material.color.getHexString() === '00ff00'
                );
                predictionPoints.forEach(point => scene.remove(point));
                
                // æ¸…é™¤é¢„æµ‹ç‚¹è¾…åŠ©çº¿
                const predictionHelpers = scene.children.filter(obj => 
                    obj.userData && obj.userData.isPrediction && obj.type === 'Line'
                );
                predictionHelpers.forEach(helper => scene.remove(helper));
                
                // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆé€šè¿‡ç±»å‹è¿‡æ»¤ï¼‰
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = 'å·²ç”Ÿæˆéšæœºæ•°æ®ï¼è¯·é‡æ–°è®¡ç®—æ¨¡å‹';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 'è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°è¿›è¡Œé¢„æµ‹';
            }
        }

        function showRegressionPlane(coeffs) {
            if (!scene) return;
            
            // ç§»é™¤æ—§çš„å›å½’å¹³é¢
            const oldPlane = scene.getObjectByName('regressionPlane');
            if (oldPlane) scene.remove(oldPlane);
            const oldEdges = scene.getObjectByName('regressionPlaneEdges');
            if (oldEdges) scene.remove(oldEdges);
            
            // è·å–å®é™…æ•°æ®èŒƒå›´
            const areas = houseData.map(d => d.area);
            const roomDataArray = houseData.map(d => d.rooms);
            const prices = houseData.map(d => d.price);
            
            const minArea = Math.min(...areas);
            const maxArea = Math.max(...areas);
            const minRooms = Math.min(...roomDataArray);
            const maxRooms = Math.max(...roomDataArray);
            
            // å¹³é¢å°ºå¯¸ï¼šä½¿ç”¨å®é™…æ•°æ®èŒƒå›´ï¼Œå¤§å¹…æ‰©å¤§
            const areaRange = maxArea - minArea;
            const roomRange = maxRooms - minRooms;
            
            const planeWidth = areaRange * 3;   // æ‰©å¤§3å€
            const planeDepth = roomRange * 150; // æ‰©å¤§150å€ï¼ˆå¯¹åº”Zè½´æ”¾å¤§50å€ï¼‰
            
            console.log('=== å¹³é¢å°ºå¯¸è®¡ç®— ===');
            console.log('æ•°æ®èŒƒå›´:', {minArea, maxArea, minRooms, maxRooms});
            console.log('å¹³é¢å°ºå¯¸:', {width: planeWidth, depth: planeDepth});
            
            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeDepth, 32, 32);
            
            // åˆ›å»ºå¹³é¢æè´¨ - å¢åŠ é€æ˜åº¦ï¼Œè®©æ•°æ®ç‚¹æ›´æ¸…æ™°
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.name = 'regressionPlane';
            
            // è®¡ç®—å¹³é¢ä¸­å¿ƒä½ç½® - ä½¿ç”¨æ•°æ®èŒƒå›´çš„ä¸­å¿ƒï¼ŒZè½´æ”¾å¤§50å€
            const centerX = (minArea + maxArea) / 2;
            const centerZ = (minRooms + maxRooms) / 2 * 50; // Zè½´æ”¾å¤§50å€
            
            // æ ¹æ®å›å½’æ–¹ç¨‹è®¡ç®—ä¸­å¿ƒç‚¹çš„Yåæ ‡
            const centerY = coeffs.a1 * centerX + coeffs.a2 * (centerZ / 50) + coeffs.b; // æ³¨æ„è¿™é‡Œè¦é™¤ä»¥50ï¼Œå› ä¸ºZè½´æ”¾å¤§äº†50å€
            
            plane.position.set(centerX, centerY, centerZ);
            
            // è®¡ç®—3Dåæ ‡ç³»ä¸­çš„æ–œç‡
            // å›å½’æ–¹ç¨‹ï¼šprice = a1*area + a2*rooms + b
            // åœ¨3Dåæ ‡ç³»ä¸­ï¼šXè½´=é¢ç§¯ï¼ŒYè½´=ä»·æ ¼ï¼ŒZè½´=å§å®¤æ•°*50
            // æ‰€ä»¥ï¼šY = a1*X + a2*(Z/50) + b
            // å¯¹Xæ±‚åå¯¼ï¼šâˆ‚Y/âˆ‚X = a1
            // å¯¹Zæ±‚åå¯¼ï¼šâˆ‚Y/âˆ‚Z = a2/50
            const slopeX = coeffs.a1;  // Xè½´æ–œç‡ï¼ˆé¢ç§¯å½±å“ï¼‰
            const slopeZ = coeffs.a2 / 50;  // Zè½´æ–œç‡ï¼ˆå§å®¤å½±å“ï¼Œå› ä¸ºZè½´æ”¾å¤§äº†50å€ï¼‰
            
            console.log('3Dåæ ‡ç³»æ–œç‡ (Zè½´æ”¾å¤§50å€):');
            console.log('- Xè½´æ–œç‡ (é¢ç§¯å½±å“):', slopeX);
            console.log('- Zè½´æ–œç‡ (å§å®¤å½±å“):', slopeZ);
            console.log('- å›å½’ç³»æ•°:', {a1: coeffs.a1, a2: coeffs.a2, b: coeffs.b});
            
            // è®¡ç®—æ—‹è½¬è§’åº¦ - ä½¿ç”¨åæ­£åˆ‡å‡½æ•°
            const rotationX = Math.atan(slopeZ); // Zè½´æ–¹å‘çš„å€¾æ–œ
            const rotationZ = Math.atan(slopeX); // Xè½´æ–¹å‘çš„å€¾æ–œ
            
            // é™åˆ¶æ—‹è½¬è§’åº¦ï¼Œé¿å…å¹³é¢è¿‡åº¦å€¾æ–œ
            const maxRotation = Math.PI / 6; // 30åº¦ï¼Œå…è®¸æ›´å¤§çš„å€¾æ–œ
            plane.rotation.x = Math.max(-maxRotation, Math.min(maxRotation, rotationX));
            plane.rotation.z = Math.max(-maxRotation, Math.min(maxRotation, rotationZ));
            
            console.log('å¹³é¢æ—‹è½¬è§’åº¦:');
            console.log('- Xè½´æ—‹è½¬ (é¢ç§¯å½±å“):', plane.rotation.z, 'å¼§åº¦');
            console.log('- Zè½´æ—‹è½¬ (å§å®¤å½±å“):', plane.rotation.x, 'å¼§åº¦');
            console.log('- æ—‹è½¬é™åˆ¶: Â±30åº¦ (Â±Ï€/6å¼§åº¦)');
            
            // éªŒè¯å¹³é¢æ˜¯å¦æ­£ç¡®é€šè¿‡æ•°æ®ç‚¹
            console.log('=== å¹³é¢éªŒè¯ ===');
            houseData.forEach((house, index) => {
                const expectedY = coeffs.a1 * house.area + coeffs.a2 * house.rooms + coeffs.b;
                const actualY = house.price;
                const deviation = Math.abs(actualY - expectedY);
                console.log(`æ•°æ®ç‚¹${index + 1}: å®é™…Y=${actualY.toFixed(2)}, å¹³é¢Y=${expectedY.toFixed(2)}, åå·®=${deviation.toFixed(2)}`);
            });
            
            // éªŒè¯å¹³é¢è¦†ç›–èŒƒå›´
            console.log('=== å¹³é¢è¦†ç›–èŒƒå›´éªŒè¯ ===');
            console.log('å¹³é¢ä¸­å¿ƒä½ç½®:', {x: centerX, y: centerY, z: centerZ});
            console.log('å¹³é¢å°ºå¯¸:', {width: planeWidth, depth: planeDepth});
            console.log('Zè½´è¦†ç›–èŒƒå›´:', {min: centerZ - planeDepth/2, max: centerZ + planeDepth/2});
            console.log('å§å®¤æ•°è¦†ç›–èŒƒå›´:', {min: (centerZ - planeDepth/2)/50, max: (centerZ + planeDepth/2)/50});
            
            scene.add(plane);
            
            // æ·»åŠ è¾¹æ¡† - å¢åŠ è¾¹æ¡†å®½åº¦ï¼Œè®©å¹³é¢æ›´æ¸…æ™°
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x1976D2, 
                linewidth: 3 
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.position.copy(plane.position);
            edges.rotation.copy(plane.rotation);
            edges.name = 'regressionPlaneEdges';
            scene.add(edges);
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯
            console.log('å›å½’ç³»æ•°:', coeffs);
            console.log('å¹³é¢ä½ç½®:', plane.position);
            console.log('å¹³é¢æ—‹è½¬:', {x: plane.rotation.x, z: plane.rotation.z});
            console.log('æ–œç‡:', {slopeX, slopeZ});
            
            // å¯è§†åŒ–å»ºè®®
            console.log('=== å¯è§†åŒ–å»ºè®® ===');
            console.log('1. è“è‰²å¹³é¢åº”è¯¥åæ˜ é¢ç§¯å’Œå§å®¤æ•°å¯¹ä»·æ ¼çš„ç»¼åˆå½±å“');
            console.log('2. æ•°æ®ç‚¹åº”è¯¥å¤§è‡´åˆ†å¸ƒåœ¨å¹³é¢é™„è¿‘');
            console.log('3. å¹³é¢å€¾æ–œæ–¹å‘åº”è¯¥ä¸æ•°æ®è¶‹åŠ¿ä¸€è‡´');
        }
        


        // æµ‹è¯•å›å½’æ¨¡å‹
        function testRegressionModel() {
            console.log('=== æµ‹è¯•å›å½’æ¨¡å‹ ===');
            const coeffs = calculateMultipleRegression();
            console.log('å›å½’ç³»æ•°:', coeffs);
            
            // æµ‹è¯•å‡ ä¸ªæ•°æ®ç‚¹
            const testPoints = [
                {area: 80, rooms: 2, price: 200},
                {area: 100, rooms: 3, price: 280},
                {area: 120, rooms: 3, price: 350}
            ];
            
            testPoints.forEach((point, index) => {
                const predictedPrice = coeffs.a1 * point.area + coeffs.a2 * point.rooms + coeffs.b;
                console.log(`æµ‹è¯•ç‚¹${index + 1}: é¢ç§¯${point.area}mÂ², å§å®¤${point.rooms}é—´, å®é™…ä»·æ ¼${point.price}ä¸‡, é¢„æµ‹ä»·æ ¼${predictedPrice.toFixed(1)}ä¸‡`);
            });
        }
        

        
        // åˆå§‹åŒ–
        window.onload = function() {
            init3DScene();
            // å»¶è¿Ÿæ‰§è¡Œæµ‹è¯•å’Œè‡ªåŠ¨è®¡ç®—æ¨¡å‹
            setTimeout(() => {
                testRegressionModel();
                // è‡ªåŠ¨è®¡ç®—æ¨¡å‹
                try {
                    const coeffs = calculateMultipleRegression();
                    if (coeffs && coeffs.a1 !== undefined) {
                        console.log('âœ… é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è®¡ç®—æ¨¡å‹æˆåŠŸ');
                        modelCalculated = true;
                        // æ˜¾ç¤º3Då›å½’å¹³é¢
                        showRegressionPlane(coeffs);
                    }
                } catch (error) {
                    console.log('âŒ é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è®¡ç®—æ¨¡å‹å¤±è´¥:', error);
                }
            }, 1000);
        };
    </script>
</body>
</html>