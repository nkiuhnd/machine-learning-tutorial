<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åˆä¸­ç”Ÿå¤šå…ƒçº¿æ€§å›å½’å­¦ä¹ å·¥å…·</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 15px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 25px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 10px;
            background: #f9f9f9;
        }
        
        .chart-container {
            position: relative;
            height: 500px;
            margin: 15px 0;
        }
        
        .three-container {
            position: relative;
            height: 600px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background: #667eea;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #764ba2;
        }
        
        .info-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .formula {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .prediction-result {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #155724;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .data-table th, .data-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .data-table th {
            background: #667eea;
            color: white;
        }
        
        .feature-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .feature-importance {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ  å¤šå…ƒçº¿æ€§å›å½’å­¦ä¹ å·¥å…·</h1>
            <p>ç”¨æˆ¿ä»·é¢„æµ‹ç†è§£å¤šå…ƒçº¿æ€§å›å½’</p>
        </div>
        
        <div class="section">
            <h2>ğŸ“Š ç¬¬ä¸€æ­¥ï¼šè§‚å¯Ÿå¤šå…ƒæ•°æ®</h2>
            <p>æˆ‘ä»¬æ¥çœ‹çœ‹æˆ¿å­çš„å„ç§ç‰¹å¾å¦‚ä½•å½±å“æˆ¿ä»·ï¼š</p>
            
            <table class="data-table" style="margin: 10px 0;">
                <thead>
                    <tr>
                        <th>æˆ¿å­</th>
                        <th>é¢ç§¯(mÂ²)</th>
                        <th>å§å®¤æ•°</th>
                        <th>æˆ¿ä»·(ä¸‡å…ƒ)</th>
                    </tr>
                </thead>
                <tbody id="dataTable">
                    <tr><td>æˆ¿å­A</td><td>80</td><td>2</td><td>200</td></tr>
                    <tr><td>æˆ¿å­B</td><td>100</td><td>3</td><td>280</td></tr>
                    <tr><td>æˆ¿å­C</td><td>120</td><td>3</td><td>350</td></tr>
                    <tr><td>æˆ¿å­D</td><td>90</td><td>2</td><td>220</td></tr>
                    <tr><td>æˆ¿å­E</td><td>150</td><td>4</td><td>450</td></tr>
                    <tr><td>æˆ¿å­F</td><td>70</td><td>2</td><td>180</td></tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>ğŸ¤” æ€è€ƒï¼šä¸€å…ƒ vs å¤šå…ƒçš„å·®åˆ«</h2>
            <div class="feature-comparison">
                <div class="feature-card">
                    <h3>ğŸ“ˆ ä¸€å…ƒçº¿æ€§å›å½’</h3>
                    <p><strong>åªæœ‰ä¸€ä¸ªç‰¹å¾</strong></p>
                    <p>å…¬å¼ï¼šæˆ¿ä»· = a Ã— é¢ç§¯ + b</p>
                    <p>ç¼ºç‚¹ï¼šåªè€ƒè™‘é¢ç§¯ï¼Œå¿½ç•¥å…¶ä»–é‡è¦å› ç´ </p>
                    <div class="info-panel">
                        <strong>ä¸¾ä¾‹ï¼š</strong>100mÂ²çš„æˆ¿å­ï¼Œä¸€å…ƒå›å½’å¯èƒ½é¢„æµ‹250ä¸‡ï¼Œä½†å®é™…å¯èƒ½å› ä¸ºæˆ¿é¾„å¤ªè€åªå€¼180ä¸‡ï¼
                    </div>
                </div>
                <div class="feature-card">
                    <h3>ğŸ  å¤šå…ƒçº¿æ€§å›å½’</h3>
                    <p><strong>å¤šä¸ªç‰¹å¾ä¸€èµ·è€ƒè™‘</strong></p>
                    <p>å…¬å¼ï¼šæˆ¿ä»· = aâ‚Ã—é¢ç§¯ + aâ‚‚Ã—å§å®¤ + aâ‚ƒÃ—æˆ¿é¾„ + aâ‚„Ã—è·ç¦» + b</p>
                    <p>ä¼˜ç‚¹ï¼šç»¼åˆè€ƒè™‘æ‰€æœ‰å› ç´ ï¼Œé¢„æµ‹æ›´å‡†ç¡®</p>
                    <div class="info-panel">
                        <strong>ä¸¾ä¾‹ï¼š</strong>åŒæ ·çš„100mÂ²æˆ¿å­ï¼Œå¤šå…ƒå›å½’ä¼šåŒæ—¶è€ƒè™‘æˆ¿é¾„ã€è·ç¦»ç­‰å› ç´ ï¼Œç»™å‡ºæ›´å‡†ç¡®çš„180ä¸‡é¢„æµ‹ï¼
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“ˆ ç¬¬äºŒæ­¥ï¼šå¯è§†åŒ–å¤šå…ƒå…³ç³»ï¼ˆ3Dç‰ˆï¼‰</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="toggleDataPoints()" id="showDataBtn" style="background: #dc3545; color: white; font-weight: bold; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                    ğŸ‘ï¸ æ˜¾ç¤º3Dæˆ¿ä»·æ•°æ®
                </button>
                <button onclick="calculateBestFitModel()" style="margin: 5px 0; background: #28a745; font-weight: bold;">ğŸ” è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹</button>
                <button onclick="resetData()" style="margin: 5px 0;">é‡ç½®æ•°æ®</button>
                <button onclick="generateRandomData()" style="margin: 5px 0;">ç”Ÿæˆéšæœºæ•°æ®</button>
                <input type="number" id="newArea" placeholder="é¢ç§¯(mÂ²)" min="50" max="200" step="5" style="margin: 5px 0;">
                <input type="number" id="newRooms" placeholder="å§å®¤æ•°" min="1" max="5" step="1" style="margin: 5px 0;">
                <input type="number" id="newPrice" placeholder="æˆ¿ä»·(ä¸‡å…ƒ)" min="100" max="500" step="10" style="margin: 5px 0;">
                <button onclick="addData()" style="margin: 5px 0;">æ‰‹åŠ¨æ·»åŠ æ•°æ®</button>
                
                <div>
                    <input type="number" id="predArea" placeholder="é¢ç§¯(mÂ²)" min="50" max="200" step="5" style="margin: 5px 0;">
                    <input type="number" id="predRooms" placeholder="å§å®¤æ•°" min="1" max="5" step="1" style="margin: 5px 0;">
                    <button onclick="makePrediction()" style="margin: 5px 0;">é¢„æµ‹æˆ¿ä»·</button>
                </div>
                
                <div id="predictionResult" class="prediction-result" style="margin: 10px 0;"></div>
                
                
            </div>
            <div class="three-container" id="threeContainer"></div>
        </div>
        

        
        <div class="section">
            <h2>ğŸ“Š ç‰¹å¾é‡è¦æ€§åˆ†æ</h2>
            <div id="featureImportance" class="feature-importance">
                <p>ğŸ’¡ è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹åï¼Œè¿™é‡Œä¼šæ˜¾ç¤ºæ¯ä¸ªç‰¹å¾å¯¹æˆ¿ä»·çš„å½±å“ç¨‹åº¦ï¼š</p>
                <div id="importanceDetails">ç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŸ¥çœ‹ç‰¹å¾æƒé‡</div>
                <div id="modelAccuracy" style="margin-top: 10px; font-weight: bold; color: #d63384;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ”¢ è®¡ç®—ç»“æœ</h2>
            <div class="formula" id="formulaDisplay" style="font-size: 14px;">
                æ­£åœ¨è®¡ç®—ä¸­...
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ¤– ä¸äººå·¥æ™ºèƒ½çš„å…³ç³»</h2>
            <div style="background: #f8d7da; padding: 15px; border-radius: 8px; border-left: 5px solid #dc3545;">
                <h3>ğŸ§  AIå¦‚ä½•ç”¨å¤šå…ƒçº¿æ€§å›å½’ï¼Ÿ</h3>
                <p><strong>æ·˜å®æ¨èï¼š</strong>æ ¹æ®ä½ çš„å¹´é¾„ã€æ€§åˆ«ã€æµè§ˆå†å²ç­‰å¤šä¸ªç‰¹å¾ï¼Œé¢„æµ‹ä½ å¯èƒ½å–œæ¬¢çš„å•†å“</p>
                <p><strong>æŠ–éŸ³æ¨èï¼š</strong>æ ¹æ®ä½ çš„è§‚çœ‹æ—¶é•¿ã€ç‚¹èµç±»å‹ã€å…³æ³¨ç”¨æˆ·ç­‰å¤šä¸ªç»´åº¦ï¼Œæ¨èä½ å¯èƒ½æ„Ÿå…´è¶£çš„è§†é¢‘</p>
                <p><strong>åŒ»ç–—è¯Šæ–­ï¼š</strong>æ ¹æ®å¹´é¾„ã€è¡€å‹ã€è¡€ç³–ã€èƒ†å›ºé†‡ç­‰å¤šä¸ªæŒ‡æ ‡ï¼Œé¢„æµ‹ç–¾ç—…é£é™©</p>
                
                <h3>ğŸ¯ å¤šå…ƒå›å½’çš„é­”åŠ›</h3>
                <p>ç°å®ä¸–ç•Œçš„é—®é¢˜å¾€å¾€æ¶‰åŠå¤šä¸ªå› ç´ ï¼Œå°±åƒæˆ¿ä»·ä¸ä»…çœ‹é¢ç§¯ï¼Œè¿˜è¦çœ‹åœ°æ®µã€æˆ¿é¾„ç­‰ã€‚å¤šå…ƒçº¿æ€§å›å½’è®©AIèƒ½å¤Ÿåƒäººç±»ä¸“å®¶ä¸€æ ·ï¼Œç»¼åˆè€ƒè™‘å„ç§å› ç´ åšå‡ºæ›´å‡†ç¡®çš„åˆ¤æ–­ï¼</p>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let scatterPoints = [];
        let regressionPlane;
        let dataPointsVisible = false;
        let modelCalculated = false;
        
        let houseData = [
            {area: 80, rooms: 2, price: 200, name: 'æˆ¿å­A'},
            {area: 100, rooms: 3, price: 280, name: 'æˆ¿å­B'},
            {area: 120, rooms: 3, price: 350, name: 'æˆ¿å­C'},
            {area: 90, rooms: 2, price: 220, name: 'æˆ¿å­D'},
            {area: 150, rooms: 4, price: 450, name: 'æˆ¿å­E'},
            {area: 70, rooms: 2, price: 180, name: 'æˆ¿å­F'}
        ];
        
        function init3DScene() {
            const container = document.getElementById('threeContainer');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            // åˆ›å»ºç›¸æœº - è°ƒæ•´è§†è§’ä»¥æ›´å¥½åœ°è§‚å¯Ÿåæ ‡ç³»
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(150, 120, 150);
            camera.lookAt(50, 50, 50);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // æ·»åŠ æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.target.set(50, 50, 50); // è®¾ç½®æ§åˆ¶ä¸­å¿ƒç‚¹
            
            // åˆ›å»ºè‡ªå®šä¹‰åæ ‡ç³»
            createCustomAxes();
            
            // æ·»åŠ ç½‘æ ¼ - åœ¨XZå¹³é¢ä¸Š
            const gridHelper = new THREE.GridHelper(100, 20, 0xcccccc, 0xcccccc);
            gridHelper.position.set(50, 0, 50);
            scene.add(gridHelper);
            
            // æ·»åŠ åæ ‡è½´æ ‡ç­¾å’Œåˆ»åº¦
            createAxisLabels();
            
            // æ·»åŠ å›¾ä¾‹è¯´æ˜
            createLegend();
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(100, 100, 100);
            scene.add(directionalLight);
            
            animate();
        }
        
        function createCustomAxes() {
            // åˆ›å»ºè‡ªå®šä¹‰åæ ‡ç³» - å·¦ä¸‹è§’ä¸ºåŸç‚¹
            const axesGroup = new THREE.Group();
            
            // Xè½´ï¼ˆé¢ç§¯ï¼‰- çº¢è‰²ï¼Œå‘å³
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(100, 0, 0)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            axesGroup.add(xAxis);
            
            // Yè½´ï¼ˆä»·æ ¼ï¼‰- ç»¿è‰²ï¼Œå‘ä¸Š
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 100, 0)
            ]);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            axesGroup.add(yAxis);
            
            // Zè½´ï¼ˆå§å®¤æ•°ï¼‰- è“è‰²ï¼Œå‘å†…
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 100)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            axesGroup.add(zAxis);
            
            // æ·»åŠ åˆ»åº¦æ ‡è®°
            for (let i = 0; i <= 10; i++) {
                const x = i * 10;
                const y = i * 10;
                const z = i * 10;
                
                // Xè½´åˆ»åº¦
                if (i > 0) {
                    const xTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, -2, 0),
                        new THREE.Vector3(x, 2, 0)
                    ]);
                    const xTick = new THREE.Line(xTickGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
                    axesGroup.add(xTick);
                }
                
                // Yè½´åˆ»åº¦
                if (i > 0) {
                    const yTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(-2, y, 0),
                        new THREE.Vector3(2, y, 0)
                    ]);
                    const yTick = new THREE.Line(yTickGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    axesGroup.add(yTick);
                }
                
                // Zè½´åˆ»åº¦
                if (i > 0) {
                    const zTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, -2, z),
                        new THREE.Vector3(0, 2, z)
                    ]);
                    const zTick = new THREE.Line(zTickGeometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                    axesGroup.add(zTick);
                }
            }
            
            scene.add(axesGroup);
        }
        
        function createAxisLabels() {
            // åˆ›å»ºæ–‡å­—ç²¾çµå‡½æ•°
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(15, 4, 1);
                
                return sprite;
            }
            
            // åˆ›å»ºåˆ»åº¦æ ‡ç­¾å‡½æ•°
            function createTickLabel(text, color = '#666666') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 32;
                
                context.font = '12px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 64, 16);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(8, 2, 1);
                
                return sprite;
            }
            
            // ä¸»åæ ‡è½´æ ‡ç­¾
            const xLabel = createTextSprite('é¢ç§¯ (mÂ²)', '#ff0000');
            xLabel.position.set(50, -8, 0);
            scene.add(xLabel);
            
            const yLabel = createTextSprite('ä»·æ ¼ (ä¸‡å…ƒ)', '#00ff00');
            yLabel.position.set(-8, 50, 0);
            scene.add(yLabel);
            
            const zLabel = createTextSprite('å§å®¤æ•°', '#0000ff');
            zLabel.position.set(0, -8, 50);
            scene.add(zLabel);
            
            // æ·»åŠ åˆ»åº¦æ ‡ç­¾
            for (let i = 1; i <= 10; i++) {
                const value = i * 10;
                
                // Xè½´åˆ»åº¦æ ‡ç­¾ï¼ˆé¢ç§¯ï¼‰
                const xTickLabel = createTickLabel(value.toString(), '#ff0000');
                xTickLabel.position.set(value, -5, 0);
                scene.add(xTickLabel);
                
                // Yè½´åˆ»åº¦æ ‡ç­¾ï¼ˆä»·æ ¼ï¼‰
                const yTickLabel = createTickLabel(value.toString(), '#00ff00');
                yTickLabel.position.set(-5, value, 0);
                scene.add(yTickLabel);
                
                // Zè½´åˆ»åº¦æ ‡ç­¾ï¼ˆå§å®¤æ•°ï¼‰
                const zTickLabel = createTickLabel(value.toString(), '#0000ff');
                zTickLabel.position.set(0, -5, value);
                scene.add(zTickLabel);
            }
        }
        
        function createLegend() {
            // åˆ›å»ºå›¾ä¾‹HTMLå…ƒç´ 
            const legendHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 12px; z-index: 100; max-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">ğŸ“Š 3Dåæ ‡ç³»è¯´æ˜</h4>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border-radius: 50%; margin-right: 8px;"></span>
                        <span>çº¢è‰²åœ†ç‚¹ = å®é™…æˆ¿ä»·æ•°æ®</span>
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: rgba(33, 150, 243, 0.4); margin-right: 8px;"></span>
                        <span>è“è‰²å¹³é¢ = å›å½’é¢„æµ‹æ¨¡å‹</span>
                    </div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>åæ ‡ç³»ï¼ˆå·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼‰ï¼š</strong></div>
                    <div style="margin: 3px 0; color: #ff0000;">ğŸ“ Xè½´ï¼ˆçº¢è‰²ï¼‰ï¼šå‘å³ = é¢ç§¯å¢åŠ </div>
                    <div style="margin: 3px 0; color: #00ff00;">ğŸ’° Yè½´ï¼ˆç»¿è‰²ï¼‰ï¼šå‘ä¸Š = ä»·æ ¼å¢åŠ </div>
                    <div style="margin: 3px 0; color: #0000ff;">ğŸ  Zè½´ï¼ˆè“è‰²ï¼‰ï¼šå‘å†… = å§å®¤æ•°å¢åŠ </div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>åˆ»åº¦è¯´æ˜ï¼š</strong></div>
                    <div style="margin: 3px 0;">é¢ç§¯ï¼š0-100mÂ²ï¼ˆXè½´åˆ»åº¦0-100ï¼‰</div>
                    <div style="margin: 3px 0;">ä»·æ ¼ï¼š0-500ä¸‡å…ƒï¼ˆYè½´åˆ»åº¦0-100ï¼Œæ˜ å°„å…³ç³»ï¼šä»·æ ¼/5ï¼‰</div>
                    <div style="margin: 3px 0;">å§å®¤ï¼š1-5é—´ï¼ˆZè½´åˆ»åº¦20-100ï¼Œæ˜ å°„å…³ç³»ï¼šå§å®¤æ•°Ã—20ï¼‰</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0; color: #666;">
                        ğŸ’¡ <em>é¼ æ ‡æ‹–æ‹½æ—‹è½¬è§†è§’ï¼Œæ»šè½®ç¼©æ”¾</em>
                    </div>
                </div>
            `;
            
            // æ·»åŠ å›¾ä¾‹åˆ°å®¹å™¨
            const container = document.getElementById('threeContainer');
            const legendDiv = document.createElement('div');
            legendDiv.innerHTML = legendHTML;
            container.style.position = 'relative';
            container.appendChild(legendDiv.firstElementChild);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function toggleDataPoints() {
            if (!dataPointsVisible) {
                show3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = 'ğŸ™ˆ éšè—3Dæˆ¿ä»·æ•°æ®';
                document.getElementById('showDataBtn').style.background = '#6c757d';
                dataPointsVisible = true;
            } else {
                hide3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = 'ğŸ‘ï¸ æ˜¾ç¤º3Dæˆ¿ä»·æ•°æ®';
                document.getElementById('showDataBtn').style.background = '#dc3545';
                dataPointsVisible = false;
            }
        }
        
        function show3DDataPoints() {
            // æ¸…é™¤ç°æœ‰æ•°æ®ç‚¹
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // æ·»åŠ æ–°çš„æ•°æ®ç‚¹ï¼Œä½¿ç”¨æ–°çš„åæ ‡ç³»
            houseData.forEach((house, index) => {
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x330000
                });
                const sphere = new THREE.Mesh(geometry, material);
                
                // æ–°çš„åæ ‡æ˜ å°„ï¼ˆå·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼‰ï¼š
                // Xè½´ï¼šé¢ç§¯ï¼ˆå‘å³ï¼Œ0-100ï¼‰
                // Yè½´ï¼šä»·æ ¼ï¼ˆå‘ä¸Šï¼Œ0-100ï¼‰
                // Zè½´ï¼šå§å®¤æ•°ï¼ˆå‘å†…ï¼Œ0-100ï¼‰
                sphere.position.set(
                    house.area,  // é¢ç§¯ç›´æ¥æ˜ å°„åˆ°Xè½´
                    house.price / 5,  // ä»·æ ¼é™¤ä»¥5æ˜ å°„åˆ°Yè½´ï¼ˆ0-500ä¸‡æ˜ å°„åˆ°0-100ï¼‰
                    house.rooms * 20  // å§å®¤æ•°ä¹˜ä»¥20æ˜ å°„åˆ°Zè½´ï¼ˆ1-5é—´æ˜ å°„åˆ°20-100ï¼‰
                );
                
                // æ·»åŠ æ•°æ®æ ‡ç­¾ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
                const label = createDataLabel(`${house.name}\n${house.area}mÂ², ${house.price}ä¸‡`);
                label.position.set(house.area + 3, house.price / 5, house.rooms * 20);
                scene.add(label);
                
                scene.add(sphere);
                scatterPoints.push(sphere);
            });
            
            // å°†æ•°æ®ç‚¹åˆ†ç»„å‘½åï¼Œä¾¿äºç®¡ç†
            const dataGroup = new THREE.Group();
            dataGroup.name = 'dataPoints';
            scatterPoints.forEach(point => dataGroup.add(point));
            scene.add(dataGroup);
        }
        
        function createDataLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 40;
            
            // ç»˜åˆ¶èƒŒæ™¯
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            context.fillRect(0, 0, 200, 40);
            context.strokeStyle = '#666';
            context.lineWidth = 1;
            context.strokeRect(0, 0, 200, 40);
            
            // ç»˜åˆ¶æ–‡å­—
            context.font = 'bold 10px Arial';
            context.fillStyle = '#333';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            const lines = text.split('\n');
            lines.forEach((line, index) => {
                context.fillText(line, 100, 10 + index * 12);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 1.6, 1);
            
            return sprite;
        }
        
        function hide3DDataPoints() {
            // æ¸…é™¤æ•°æ®ç‚¹
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾
            if (scene) {
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
        }
        
        function showRegressionPlane(coeffs) {
            if (!scene) return;
            
            // ç§»é™¤æ—§çš„å›å½’å¹³é¢
            const oldPlane = scene.getObjectByName('regressionPlane');
            if (oldPlane) scene.remove(oldPlane);
            const oldEdges = scene.getObjectByName('regressionPlaneEdges');
            if (oldEdges) scene.remove(oldEdges);
            
            // è·å–å®é™…æ•°æ®èŒƒå›´
            const areas = houseData.map(d => d.area);
            const rooms = houseData.map(d => d.rooms);
            const prices = houseData.map(d => d.price);
            
            const minArea = Math.min(...areas);
            const maxArea = Math.max(...areas);
            const minRooms = Math.min(...rooms);
            const maxRooms = Math.max(...rooms);
            
            // åˆ›å»ºå›å½’å¹³é¢ - ä½¿ç”¨ä¸æ•°æ®ç‚¹ç›¸åŒçš„åæ ‡ç³»æ˜ å°„
            const planeWidth = maxArea - minArea;
            const planeDepth = (maxRooms - minRooms) * 20;
            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeDepth, 20, 20);
            
            // è®¡ç®—å¹³é¢4ä¸ªè§’ç‚¹åœ¨3Dåæ ‡ç³»ä¸­çš„Yåæ ‡ï¼ˆä»·æ ¼ï¼‰
            const cornerPrices = [
                (coeffs.a1 * minArea + coeffs.a2 * minRooms + coeffs.b) / 5,  // æ˜ å°„åˆ°Yè½´
                (coeffs.a1 * maxArea + coeffs.a2 * minRooms + coeffs.b) / 5,
                (coeffs.a1 * maxArea + coeffs.a2 * maxRooms + coeffs.b) / 5,
                (coeffs.a1 * minArea + coeffs.a2 * maxRooms + coeffs.b) / 5
            ];
            
            // è®¡ç®—å¹³å‡é«˜åº¦
            const avgPrice = (cornerPrices.reduce((a, b) => a + b, 0) / 4);
            
            // åˆ›å»ºå¹³é¢æè´¨
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.name = 'regressionPlane';
            
            // è®¾ç½®å¹³é¢ä½ç½® - ä½¿ç”¨ä¸æ•°æ®ç‚¹ç›¸åŒçš„åæ ‡ç³»
            plane.position.set(
                (minArea + maxArea) / 2,  // Xè½´ï¼šé¢ç§¯ä¸­å¿ƒ
                avgPrice,  // Yè½´ï¼šå¹³å‡ä»·æ ¼ï¼ˆå·²æ˜ å°„ï¼‰
                ((minRooms + maxRooms) / 2) * 20  // Zè½´ï¼šå§å®¤æ•°ä¸­å¿ƒï¼ˆå·²æ˜ å°„ï¼‰
            );
            
            // æ ¹æ®å›å½’ç³»æ•°è®¡ç®—æ­£ç¡®çš„å€¾æ–œè§’åº¦
            // æ³¨æ„ï¼šåœ¨3Dåæ ‡ç³»ä¸­ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘æ˜ å°„å…³ç³»
            const slopeX = coeffs.a1 / 5;  // é¢ç§¯å¯¹ä»·æ ¼çš„å½±å“ï¼ˆå·²æ˜ å°„ï¼‰
            const slopeZ = coeffs.a2 * 20 / 5;  // å§å®¤æ•°å¯¹ä»·æ ¼çš„å½±å“ï¼ˆå·²æ˜ å°„ï¼‰
            
            // è®¾ç½®æ­£ç¡®çš„æ—‹è½¬è§’åº¦
            plane.rotation.x = -Math.atan(slopeZ); // Zè½´æ–¹å‘çš„å€¾æ–œ
            plane.rotation.z = Math.atan(slopeX); // Xè½´æ–¹å‘çš„å€¾æ–œ
            
            scene.add(plane);
            
            // æ·»åŠ è¾¹æ¡†
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x1976D2, 
                linewidth: 2 
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.position.copy(plane.position);
            edges.rotation.copy(plane.rotation);
            edges.name = 'regressionPlaneEdges';
            scene.add(edges);
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯
            console.log('å›å½’ç³»æ•°:', coeffs);
            console.log('æ•°æ®èŒƒå›´:', {minArea, maxArea, minRooms, maxRooms});
            console.log('å¹³é¢ä½ç½®:', plane.position);
            console.log('å¹³é¢æ—‹è½¬:', {x: plane.rotation.x, z: plane.rotation.z});
            
            // éªŒè¯å›å½’æ¨¡å‹
            console.log('=== å›å½’æ¨¡å‹éªŒè¯ ===');
            houseData.forEach((house, index) => {
                const predictedPrice = coeffs.a1 * house.area + coeffs.a2 * house.rooms + coeffs.b;
                const error = house.price - predictedPrice;
                console.log(`æ•°æ®ç‚¹${index + 1}: å®é™…${house.price}ä¸‡, é¢„æµ‹${predictedPrice.toFixed(1)}ä¸‡, è¯¯å·®${error.toFixed(1)}ä¸‡`);
            });
        }

        function calculateMultipleRegression() {
            // äºŒå…ƒçº¿æ€§å›å½’è®¡ç®—ï¼ˆé¢ç§¯å’Œå§å®¤æ•°ï¼‰
            const n = houseData.length;
            
            // è®¡ç®—å‡å€¼
            const meanArea = houseData.reduce((sum, d) => sum + d.area, 0) / n;
            const meanRooms = houseData.reduce((sum, d) => sum + d.rooms, 0) / n;
            const meanPrice = houseData.reduce((sum, d) => sum + d.price, 0) / n;
            
            // è®¡ç®—åæ–¹å·®å’Œæ–¹å·®
            let covAreaPrice = 0, covRoomsPrice = 0, varArea = 0, varRooms = 0, covAreaRooms = 0;
            
            houseData.forEach(d => {
                covAreaPrice += (d.area - meanArea) * (d.price - meanPrice);
                covRoomsPrice += (d.rooms - meanRooms) * (d.price - meanPrice);
                varArea += (d.area - meanArea) ** 2;
                varRooms += (d.rooms - meanRooms) ** 2;
                covAreaRooms += (d.area - meanArea) * (d.rooms - meanRooms);
            });
            
            // è§£äºŒå…ƒçº¿æ€§æ–¹ç¨‹ç»„
            const denominator = varArea * varRooms - covAreaRooms ** 2;
            const a1 = (covAreaPrice * varRooms - covRoomsPrice * covAreaRooms) / denominator;
            const a2 = (covRoomsPrice * varArea - covAreaPrice * covAreaRooms) / denominator;
            const b = meanPrice - a1 * meanArea - a2 * meanRooms;
            
            return {a1, a2, b};
        }
        
        function calculateBestFitModel() {
            if (!dataPointsVisible) {
                alert('è¯·å…ˆç‚¹å‡»"æ˜¾ç¤ºæˆ¿ä»·æ•°æ®"æŒ‰é’®ï¼');
                return;
            }
            
            if (houseData.length < 3) {
                alert('éœ€è¦è‡³å°‘3ä¸ªæ•°æ®ç‚¹æ‰èƒ½è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹ï¼');
                return;
            }
            
            document.getElementById('formulaDisplay').innerHTML = 
                'ğŸ§® æ­£åœ¨ç”¨å¤šå…ƒçº¿æ€§å›å½’è®¡ç®—æœ€ä½³æ¨¡å‹...';
            
            const coeffs = calculateMultipleRegression();
            
            // ç›´æ¥æ˜¾ç¤º3Då›å½’å¹³é¢ï¼ˆç§»é™¤Chart.jsä¾èµ–ï¼‰
            setTimeout(() => {
                // æ˜¾ç¤ºäºŒå…ƒå›å½’å…¬å¼
                document.getElementById('formulaDisplay').innerHTML = 
                    `ğŸ“Š äºŒå…ƒçº¿æ€§å›å½’ç»“æœï¼š<br>æˆ¿ä»· = ${coeffs.a1.toFixed(1)}Ã—é¢ç§¯ + ${coeffs.a2.toFixed(1)}Ã—å§å®¤æ•° + ${coeffs.b.toFixed(1)}<br><br>ğŸ¯ è¿™ä¸ªæ¨¡å‹ç»¼åˆè€ƒè™‘äº†é¢ç§¯å’Œå§å®¤æ•°ï¼`;
                
                // æ˜¾ç¤ºç‰¹å¾é‡è¦æ€§ï¼ˆäºŒç»´ï¼‰
                document.getElementById('importanceDetails').innerHTML = 
                    `<strong>ğŸ† ç‰¹å¾é‡è¦æ€§ï¼š</strong><br>
                    1. é¢ç§¯ï¼šæ¯å¢åŠ 1mÂ²ï¼Œæˆ¿ä»·+${coeffs.a1.toFixed(1)}ä¸‡å…ƒ<br>
                    2. å§å®¤æ•°ï¼šæ¯å¤š1é—´ï¼Œæˆ¿ä»·+${coeffs.a2.toFixed(1)}ä¸‡å…ƒ`;
                
                document.getElementById('modelAccuracy').innerHTML = 
                    `ğŸ“ˆ 3Dæ¨¡å‹å±•ç¤ºï¼šçº¢è‰²ç‚¹=å®é™…æ•°æ®ï¼Œè“è‰²å¹³é¢=å›å½’é¢„æµ‹`;
                
                // æ˜¾ç¤º3Då›å½’å¹³é¢
                showRegressionPlane(coeffs);
                
                modelCalculated = true;
            }, 500);
        }


        
        function makePrediction() {
            if (!modelCalculated) {
                alert('è¯·å…ˆç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŒ‰é’®ï¼');
                return;
            }
            
            const area = parseFloat(document.getElementById('predArea').value);
            const rooms = parseFloat(document.getElementById('predRooms').value);
            
            if (isNaN(area) || isNaN(rooms)) {
                alert('è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°ï¼');
                return;
            }
            
            // ä½¿ç”¨äºŒå…ƒå›å½’ç³»æ•°è¿›è¡Œé¢„æµ‹
            const coeffs = calculateMultipleRegression();
            const predictedPrice = coeffs.a1 * area + coeffs.a2 * rooms + coeffs.b;
            
            // åœ¨3Dåœºæ™¯ä¸­æ˜¾ç¤ºé¢„æµ‹ç‚¹
            const predictionGeometry = new THREE.SphereGeometry(3, 16, 16);
            const predictionMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x003300
            });
            const predictionSphere = new THREE.Mesh(predictionGeometry, predictionMaterial);
            
            // ä½¿ç”¨ä¸æ•°æ®ç‚¹ç›¸åŒçš„åæ ‡ç³»æ˜ å°„
            predictionSphere.position.set(
                area,  // é¢ç§¯
                predictedPrice / 5,  // ä»·æ ¼é™¤ä»¥5ï¼ˆä¸æ•°æ®ç‚¹ä¸€è‡´ï¼‰
                rooms * 20  // å§å®¤æ•°ä¹˜ä»¥20ï¼ˆä¸æ•°æ®ç‚¹ä¸€è‡´ï¼‰
            );
            
            // æ·»åŠ é¢„æµ‹ç‚¹æ ‡ç­¾
            const predictionLabel = createDataLabel(`é¢„æµ‹\n${area}mÂ², ${predictedPrice.toFixed(1)}ä¸‡`);
            predictionLabel.position.set(area + 3, predictedPrice / 5, rooms * 20);
            scene.add(predictionLabel);
            scene.add(predictionSphere);
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯
            console.log('é¢„æµ‹ç‚¹ä½ç½®:', predictionSphere.position);
            console.log('é¢„æµ‹ç»“æœ:', {area, rooms, predictedPrice});
            
            // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 
                    `ğŸ¯ é¢„æµ‹ç»“æœï¼šè¿™å¥—æˆ¿å­çš„ä»·æ ¼å¤§çº¦æ˜¯${predictedPrice.toFixed(1)}ä¸‡å…ƒ`;
            }
        }

        function addData() {
            const area = parseFloat(document.getElementById('newArea').value);
            const rooms = parseFloat(document.getElementById('newRooms').value);
            const price = parseFloat(document.getElementById('newPrice').value);
            
            if (isNaN(area) || isNaN(rooms) || isNaN(price)) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—ï¼');
                return;
            }
            
            houseData.push({area, rooms, price, name: 'æ–°æˆ¿å­'});
            
            // æ›´æ–°è¡¨æ ¼
            const tbody = document.getElementById('dataTable');
            const row = tbody.insertRow();
            row.innerHTML = `<td>æ–°æˆ¿å­</td><td>${area}</td><td>${rooms}</td><td>${price}</td>`;
            
            // æ¸…é™¤3Dåœºæ™¯ä¸­çš„æ‰€æœ‰å…ƒç´ 
            if (scene) {
                // æ¸…é™¤æ•°æ®ç‚¹
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // æ¸…é™¤å›å½’å¹³é¢
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // æ¸…é™¤å›å½’å¹³é¢è¾¹æ¡†
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆé€šè¿‡ç±»å‹è¿‡æ»¤ï¼‰
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = 'å·²æ·»åŠ æ–°æ•°æ®ï¼è¯·é‡æ–°è®¡ç®—æ¨¡å‹';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 'è¯·è¾“å…¥æˆ¿å­ç‰¹å¾è¿›è¡Œé¢„æµ‹';
            }
        }

        function resetData() {
            houseData = [
                {area: 80, rooms: 2, price: 200, name: 'æˆ¿å­A'},
                {area: 100, rooms: 3, price: 280, name: 'æˆ¿å­B'},
                {area: 120, rooms: 3, price: 350, name: 'æˆ¿å­C'},
                {area: 90, rooms: 2, price: 220, name: 'æˆ¿å­D'},
                {area: 150, rooms: 4, price: 450, name: 'æˆ¿å­E'},
                {area: 70, rooms: 2, price: 180, name: 'æˆ¿å­F'}
            ];
            
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = `
                <tr><td>æˆ¿å­A</td><td>80</td><td>2</td><td>200</td></tr>
                <tr><td>æˆ¿å­B</td><td>100</td><td>3</td><td>280</td></tr>
                <tr><td>æˆ¿å­C</td><td>120</td><td>3</td><td>350</td></tr>
                <tr><td>æˆ¿å­D</td><td>90</td><td>2</td><td>220</td></tr>
                <tr><td>æˆ¿å­E</td><td>150</td><td>4</td><td>450</td></tr>
                <tr><td>æˆ¿å­F</td><td>70</td><td>2</td><td>180</td></tr>
            `;
            
            // æ¸…é™¤3Dåœºæ™¯ä¸­çš„æ‰€æœ‰å…ƒç´ 
            if (scene) {
                // æ¸…é™¤æ•°æ®ç‚¹
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // æ¸…é™¤å›å½’å¹³é¢
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // æ¸…é™¤å›å½’å¹³é¢è¾¹æ¡†
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆé€šè¿‡ç±»å‹è¿‡æ»¤ï¼‰
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            dataPointsVisible = false;
            modelCalculated = false;
            
            document.getElementById('showDataBtn').innerHTML = 'ğŸ‘ï¸ æ˜¾ç¤º3Dæˆ¿ä»·æ•°æ®';
            document.getElementById('showDataBtn').style.background = '#dc3545';
            document.getElementById('formulaDisplay').innerHTML = 'æ­£åœ¨è®¡ç®—ä¸­...';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 'è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°è¿›è¡Œé¢„æµ‹';
            }
            document.getElementById('importanceDetails').innerHTML = 'ç‚¹å‡»"è®¡ç®—å¤šå…ƒå›å½’æ¨¡å‹"æŸ¥çœ‹ç‰¹å¾æƒé‡';
            document.getElementById('modelAccuracy').innerHTML = '';
        }

        function generateRandomData() {
            houseData = [];
            const names = ['æˆ¿å­G', 'æˆ¿å­H', 'æˆ¿å­I', 'æˆ¿å­J', 'æˆ¿å­K', 'æˆ¿å­L'];
            
            for (let i = 0; i < 6; i++) {
                const area = Math.floor(Math.random() * 100) + 60; // 60-160
                const rooms = Math.floor(Math.random() * 3) + 2; // 2-4
                const price = Math.floor(area * 2.5 + rooms * 30 + Math.random() * 50 + 50);
                
                houseData.push({area, rooms, price, name: names[i]});
            }
            
            // æ›´æ–°è¡¨æ ¼
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            houseData.forEach(house => {
                const row = tbody.insertRow();
                row.innerHTML = `<td>${house.name}</td><td>${house.area}</td><td>${house.rooms}</td><td>${house.price}</td>`;
            });
            
            // æ¸…é™¤3Dåœºæ™¯ä¸­çš„æ‰€æœ‰å…ƒç´ 
            if (scene) {
                // æ¸…é™¤æ•°æ®ç‚¹
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // æ¸…é™¤å›å½’å¹³é¢
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // æ¸…é™¤å›å½’å¹³é¢è¾¹æ¡†
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // æ¸…é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆé€šè¿‡ç±»å‹è¿‡æ»¤ï¼‰
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = 'å·²ç”Ÿæˆéšæœºæ•°æ®ï¼è¯·é‡æ–°è®¡ç®—æ¨¡å‹';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 'è¯·è¾“å…¥é¢ç§¯å’Œå§å®¤æ•°è¿›è¡Œé¢„æµ‹';
            }
        }

        function showRegressionPlane(coeffs) {
            if (!scene) return;
            
            // ç§»é™¤æ—§çš„å›å½’å¹³é¢
            const oldPlane = scene.getObjectByName('regressionPlane');
            if (oldPlane) scene.remove(oldPlane);
            const oldEdges = scene.getObjectByName('regressionPlaneEdges');
            if (oldEdges) scene.remove(oldEdges);
            
            // è·å–å®é™…æ•°æ®èŒƒå›´
            const areas = houseData.map(d => d.area);
            const rooms = houseData.map(d => d.rooms);
            const prices = houseData.map(d => d.price);
            
            const minArea = Math.min(...areas) - 10;
            const maxArea = Math.max(...areas) + 10;
            const minRooms = Math.min(...rooms) - 0.5;
            const maxRooms = Math.max(...rooms) + 0.5;
            const minPrice = Math.min(...prices) - 20;
            const maxPrice = Math.max(...prices) + 20;
            
            // é‡æ–°æ˜ å°„åæ ‡ç³»ï¼š
            // Xè½´ï¼šé¢ç§¯ï¼ˆå·¦å³æ–¹å‘ï¼‰
            // Yè½´ï¼šä»·æ ¼ï¼ˆä¸Šä¸‹æ–¹å‘ï¼‰  
            // Zè½´ï¼šå§å®¤æ•°ï¼ˆå‰åæ–¹å‘ï¼‰
            
            // è®¡ç®—å®é™…æ•°æ®åœ¨3Dç©ºé—´ä¸­çš„ä¸­å¿ƒç‚¹
            const centerX = (minArea + maxArea) / 2 - 100; // å‡å»100æ˜¯ä¹‹å‰çš„åç§»
            const centerY = (minPrice + maxPrice) / 2 - 300; // å‡å»300æ˜¯ä¹‹å‰çš„åç§»
            const centerZ = ((minRooms + maxRooms) / 2) * 20 - 60; // ä¹˜ä»¥20æ˜¯ä¹‹å‰çš„ç¼©æ”¾
            
            // åˆ›å»ºè¶³å¤Ÿå¤§çš„å¹³é¢ - ä½¿ç”¨å®é™…3Dåæ ‡ç³»ä¸­çš„å°ºå¯¸
            const planeWidth = maxArea - minArea;  // Xè½´æ–¹å‘çš„å®½åº¦
            const planeDepth = (maxRooms - minRooms) * 20;  // Zè½´æ–¹å‘çš„æ·±åº¦ï¼ˆè€ƒè™‘ç¼©æ”¾å› å­ï¼‰
            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeDepth, 20, 20);
            
            // è®¡ç®—å¹³é¢4ä¸ªè§’ç‚¹çš„å®é™…ä»·æ ¼
            const cornerPrices = [
                coeffs.a1 * minArea + coeffs.a2 * minRooms + coeffs.b,
                coeffs.a1 * maxArea + coeffs.a2 * minRooms + coeffs.b,
                coeffs.a1 * maxArea + coeffs.a2 * maxRooms + coeffs.b,
                coeffs.a1 * minArea + coeffs.a2 * maxRooms + coeffs.b
            ];
            
            // è®¡ç®—å¹³å‡é«˜åº¦
            const avgPrice = (cornerPrices.reduce((a, b) => a + b, 0) / 4);
            
            // åˆ›å»ºå¹³é¢æè´¨
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.name = 'regressionPlane';
            
            // è®¾ç½®å¹³é¢ä½ç½® - ä½¿ç”¨ä¸æ•°æ®ç‚¹ç›¸åŒçš„åæ ‡ç³»
            plane.position.set(
                (minArea + maxArea) / 2 - 100,
                avgPrice - 300,
                ((minRooms + maxRooms) / 2) * 20 - 60
            );
            
            // æ ¹æ®å›å½’ç³»æ•°è®¡ç®—æ­£ç¡®çš„å€¾æ–œè§’åº¦
            // è®¡ç®—å¹³é¢çš„æ³•å‘é‡æ–¹å‘
            const slopeX = coeffs.a1; // é¢ç§¯ç³»æ•°
            const slopeZ = coeffs.a2; // å§å®¤ç³»æ•°
            
            // è®¾ç½®æ­£ç¡®çš„æ—‹è½¬è§’åº¦
            plane.rotation.x = -Math.atan(slopeZ / 20); // Zè½´æ–¹å‘çš„å€¾æ–œ
            plane.rotation.z = Math.atan(slopeX); // Xè½´æ–¹å‘çš„å€¾æ–œ
            
            scene.add(plane);
            
            // æ·»åŠ è¾¹æ¡†
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x1976D2, 
                linewidth: 3 
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.position.copy(plane.position);
            edges.rotation.copy(plane.rotation);
            edges.name = 'regressionPlaneEdges';
            scene.add(edges);
            
            // æ·»åŠ åæ ‡è½´æ ‡ç­¾
            updateAxisLabels(minArea, maxArea, minRooms, maxRooms, minPrice, maxPrice);
        }
        
        function updateAxisLabels(minArea, maxArea, minRooms, maxRooms, minPrice, maxPrice) {
            // æ›´æ–°æˆ–åˆ›å»ºåæ ‡è½´æ ‡ç­¾
            const existingLabels = scene.children.filter(obj => obj.name && obj.name.includes('axisLabel'));
            existingLabels.forEach(label => scene.remove(label));
            
            // åˆ›å»ºæ–°çš„åæ ‡è½´æ ‡ç­¾
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(30, 7.5, 1);
                
                return sprite;
            }
            
            // Xè½´æ ‡ç­¾
            const xLabel = createTextSprite(`é¢ç§¯ (${minArea}-${maxArea}mÂ²)`);
            xLabel.position.set(maxArea - 100 + 20, -10, 0);
            xLabel.name = 'axisLabelX';
            scene.add(xLabel);
            
            // Yè½´æ ‡ç­¾
            const yLabel = createTextSprite(`ä»·æ ¼ (${minPrice}-${maxPrice}ä¸‡å…ƒ)`);
            yLabel.position.set(0, maxPrice - 300 + 20, 0);
            yLabel.name = 'axisLabelY';
            scene.add(yLabel);
            
            // Zè½´æ ‡ç­¾
            const zLabel = createTextSprite(`å§å®¤æ•° (${minRooms}-${maxRooms}é—´)`);
            zLabel.position.set(0, -10, maxRooms * 20 - 60 + 20);
            zLabel.name = 'axisLabelZ';
            scene.add(zLabel);
        }

        // æµ‹è¯•å›å½’æ¨¡å‹
        function testRegressionModel() {
            console.log('=== æµ‹è¯•å›å½’æ¨¡å‹ ===');
            const coeffs = calculateMultipleRegression();
            console.log('å›å½’ç³»æ•°:', coeffs);
            
            // æµ‹è¯•å‡ ä¸ªæ•°æ®ç‚¹
            const testPoints = [
                {area: 80, rooms: 2, price: 200},
                {area: 100, rooms: 3, price: 280},
                {area: 120, rooms: 3, price: 350}
            ];
            
            testPoints.forEach((point, index) => {
                const predictedPrice = coeffs.a1 * point.area + coeffs.a2 * point.rooms + coeffs.b;
                console.log(`æµ‹è¯•ç‚¹${index + 1}: é¢ç§¯${point.area}mÂ², å§å®¤${point.rooms}é—´, å®é™…ä»·æ ¼${point.price}ä¸‡, é¢„æµ‹ä»·æ ¼${predictedPrice.toFixed(1)}ä¸‡`);
            });
        }
        
        // åˆå§‹åŒ–
        window.onload = function() {
            init3DScene();
            // å»¶è¿Ÿæ‰§è¡Œæµ‹è¯•
            setTimeout(testRegressionModel, 1000);
        };
    </script>
</body>
</html>