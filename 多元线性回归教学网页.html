<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初中生多元线性回归学习工具</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 15px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 25px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 10px;
            background: #f9f9f9;
        }
        
        .chart-container {
            position: relative;
            height: 500px;
            margin: 15px 0;
        }
        
        .three-container {
            position: relative;
            height: 600px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background: #667eea;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #764ba2;
        }
        
        .info-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .formula {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .prediction-result {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #155724;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .data-table th, .data-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .data-table th {
            background: #667eea;
            color: white;
        }
        
        .feature-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .feature-importance {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🏠 多元线性回归学习工具</h1>
            <p>用房价预测理解多元线性回归</p>
        </div>
        
        <div class="section">
            <h2>📊 第一步：观察多元数据</h2>
            <p>我们来看看房子的各种特征如何影响房价：</p>
            
            <table class="data-table" style="margin: 10px 0;">
                <thead>
                    <tr>
                        <th>房子</th>
                        <th>面积(m²)</th>
                        <th>卧室数</th>
                        <th>房价(万元)</th>
                    </tr>
                </thead>
                <tbody id="dataTable">
                    <tr><td>房子A</td><td>80</td><td>2</td><td>200</td></tr>
                    <tr><td>房子B</td><td>100</td><td>3</td><td>280</td></tr>
                    <tr><td>房子C</td><td>120</td><td>3</td><td>350</td></tr>
                    <tr><td>房子D</td><td>90</td><td>2</td><td>220</td></tr>
                    <tr><td>房子E</td><td>150</td><td>4</td><td>450</td></tr>
                    <tr><td>房子F</td><td>70</td><td>2</td><td>180</td></tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>🤔 思考：一元 vs 多元的差别</h2>
            <div class="feature-comparison">
                <div class="feature-card">
                    <h3>📈 一元线性回归</h3>
                    <p><strong>只有一个特征</strong></p>
                    <p>公式：房价 = a × 面积 + b</p>
                    <p>缺点：只考虑面积，忽略其他重要因素</p>
                    <div class="info-panel">
                        <strong>举例：</strong>100m²的房子，一元回归可能预测250万，但实际可能因为房龄太老只值180万！
                    </div>
                </div>
                <div class="feature-card">
                    <h3>🏠 多元线性回归</h3>
                    <p><strong>多个特征一起考虑</strong></p>
                    <p>公式：房价 = a₁×面积 + a₂×卧室 + a₃×房龄 + a₄×距离 + b</p>
                    <p>优点：综合考虑所有因素，预测更准确</p>
                    <div class="info-panel">
                        <strong>举例：</strong>同样的100m²房子，多元回归会同时考虑房龄、距离等因素，给出更准确的180万预测！
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>📈 第二步：可视化多元关系（3D版）</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="toggleDataPoints()" id="showDataBtn" style="background: #dc3545; color: white; font-weight: bold; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                    👁️ 显示3D房价数据
                </button>
                <button onclick="calculateBestFitModel()" style="margin: 5px 0; background: #28a745; font-weight: bold;">🔍 计算多元回归模型</button>
                <button onclick="resetData()" style="margin: 5px 0;">重置数据</button>
                <button onclick="generateRandomData()" style="margin: 5px 0;">生成随机数据</button>
                <input type="number" id="newArea" placeholder="面积(m²)" min="50" max="200" step="5" style="margin: 5px 0;">
                <input type="number" id="newRooms" placeholder="卧室数" min="1" max="5" step="1" style="margin: 5px 0;">
                <input type="number" id="newPrice" placeholder="房价(万元)" min="100" max="500" step="10" style="margin: 5px 0;">
                <button onclick="addData()" style="margin: 5px 0;">手动添加数据</button>
                
                <div>
                    <input type="number" id="predArea" placeholder="面积(m²)" min="50" max="200" step="5" style="margin: 5px 0;">
                    <input type="number" id="predRooms" placeholder="卧室数" min="1" max="5" step="1" style="margin: 5px 0;">
                    <button onclick="makePrediction()" style="margin: 5px 0;">预测房价</button>
                </div>
                
                <div id="predictionResult" class="prediction-result" style="margin: 10px 0;"></div>
                
                
            </div>
            <div class="three-container" id="threeContainer"></div>
        </div>
        

        
        <div class="section">
            <h2>📊 特征重要性分析</h2>
            <div id="featureImportance" class="feature-importance">
                <p>💡 计算多元回归模型后，这里会显示每个特征对房价的影响程度：</p>
                <div id="importanceDetails">点击"计算多元回归模型"查看特征权重</div>
                <div id="modelAccuracy" style="margin-top: 10px; font-weight: bold; color: #d63384;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>🔢 计算结果</h2>
            <div class="formula" id="formulaDisplay" style="font-size: 14px;">
                正在计算中...
            </div>
        </div>
        
        <div class="section">
            <h2>🤖 与人工智能的关系</h2>
            <div style="background: #f8d7da; padding: 15px; border-radius: 8px; border-left: 5px solid #dc3545;">
                <h3>🧠 AI如何用多元线性回归？</h3>
                <p><strong>淘宝推荐：</strong>根据你的年龄、性别、浏览历史等多个特征，预测你可能喜欢的商品</p>
                <p><strong>抖音推荐：</strong>根据你的观看时长、点赞类型、关注用户等多个维度，推荐你可能感兴趣的视频</p>
                <p><strong>医疗诊断：</strong>根据年龄、血压、血糖、胆固醇等多个指标，预测疾病风险</p>
                
                <h3>🎯 多元回归的魔力</h3>
                <p>现实世界的问题往往涉及多个因素，就像房价不仅看面积，还要看地段、房龄等。多元线性回归让AI能够像人类专家一样，综合考虑各种因素做出更准确的判断！</p>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let scatterPoints = [];
        let regressionPlane;
        let dataPointsVisible = false;
        let modelCalculated = false;
        
        let houseData = [
            {area: 80, rooms: 2, price: 200, name: '房子A'},
            {area: 100, rooms: 3, price: 280, name: '房子B'},
            {area: 120, rooms: 3, price: 350, name: '房子C'},
            {area: 90, rooms: 2, price: 220, name: '房子D'},
            {area: 150, rooms: 4, price: 450, name: '房子E'},
            {area: 70, rooms: 2, price: 180, name: '房子F'}
        ];
        
        function init3DScene() {
            const container = document.getElementById('threeContainer');
            
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            // 创建相机 - 调整视角以更好地观察坐标系
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(150, 120, 150);
            camera.lookAt(50, 50, 50);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // 添加控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.target.set(50, 50, 50); // 设置控制中心点
            
            // 创建自定义坐标系
            createCustomAxes();
            
            // 添加网格 - 在XZ平面上
            const gridHelper = new THREE.GridHelper(100, 20, 0xcccccc, 0xcccccc);
            gridHelper.position.set(50, 0, 50);
            scene.add(gridHelper);
            
            // 添加坐标轴标签和刻度
            createAxisLabels();
            
            // 添加图例说明
            createLegend();
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(100, 100, 100);
            scene.add(directionalLight);
            
            animate();
        }
        
        function createCustomAxes() {
            // 创建自定义坐标系 - 左下角为原点
            const axesGroup = new THREE.Group();
            
            // X轴（面积）- 红色，向右
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(100, 0, 0)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            axesGroup.add(xAxis);
            
            // Y轴（价格）- 绿色，向上
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 100, 0)
            ]);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            axesGroup.add(yAxis);
            
            // Z轴（卧室数）- 蓝色，向内
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 100)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            axesGroup.add(zAxis);
            
            // 添加刻度标记
            for (let i = 0; i <= 10; i++) {
                const x = i * 10;
                const y = i * 10;
                const z = i * 10;
                
                // X轴刻度
                if (i > 0) {
                    const xTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, -2, 0),
                        new THREE.Vector3(x, 2, 0)
                    ]);
                    const xTick = new THREE.Line(xTickGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
                    axesGroup.add(xTick);
                }
                
                // Y轴刻度
                if (i > 0) {
                    const yTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(-2, y, 0),
                        new THREE.Vector3(2, y, 0)
                    ]);
                    const yTick = new THREE.Line(yTickGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    axesGroup.add(yTick);
                }
                
                // Z轴刻度
                if (i > 0) {
                    const zTickGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, -2, z),
                        new THREE.Vector3(0, 2, z)
                    ]);
                    const zTick = new THREE.Line(zTickGeometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                    axesGroup.add(zTick);
                }
            }
            
            scene.add(axesGroup);
        }
        
        function createAxisLabels() {
            // 创建文字精灵函数
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(15, 4, 1);
                
                return sprite;
            }
            
            // 创建刻度标签函数
            function createTickLabel(text, color = '#666666') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 32;
                
                context.font = '12px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 64, 16);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(8, 2, 1);
                
                return sprite;
            }
            
            // 主坐标轴标签
            const xLabel = createTextSprite('面积 (m²)', '#ff0000');
            xLabel.position.set(50, -8, 0);
            scene.add(xLabel);
            
            const yLabel = createTextSprite('价格 (万元)', '#00ff00');
            yLabel.position.set(-8, 50, 0);
            scene.add(yLabel);
            
            const zLabel = createTextSprite('卧室数', '#0000ff');
            zLabel.position.set(0, -8, 50);
            scene.add(zLabel);
            
            // 添加刻度标签
            for (let i = 1; i <= 10; i++) {
                const value = i * 10;
                
                // X轴刻度标签（面积）
                const xTickLabel = createTickLabel(value.toString(), '#ff0000');
                xTickLabel.position.set(value, -5, 0);
                scene.add(xTickLabel);
                
                // Y轴刻度标签（价格）
                const yTickLabel = createTickLabel(value.toString(), '#00ff00');
                yTickLabel.position.set(-5, value, 0);
                scene.add(yTickLabel);
                
                // Z轴刻度标签（卧室数）
                const zTickLabel = createTickLabel(value.toString(), '#0000ff');
                zTickLabel.position.set(0, -5, value);
                scene.add(zTickLabel);
            }
        }
        
        function createLegend() {
            // 创建图例HTML元素
            const legendHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 12px; z-index: 100; max-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">📊 3D坐标系说明</h4>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border-radius: 50%; margin-right: 8px;"></span>
                        <span>红色圆点 = 实际房价数据</span>
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: rgba(33, 150, 243, 0.4); margin-right: 8px;"></span>
                        <span>蓝色平面 = 回归预测模型</span>
                    </div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>坐标系（左下角为原点）：</strong></div>
                    <div style="margin: 3px 0; color: #ff0000;">📏 X轴（红色）：向右 = 面积增加</div>
                    <div style="margin: 3px 0; color: #00ff00;">💰 Y轴（绿色）：向上 = 价格增加</div>
                    <div style="margin: 3px 0; color: #0000ff;">🏠 Z轴（蓝色）：向内 = 卧室数增加</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0;"><strong>刻度说明：</strong></div>
                    <div style="margin: 3px 0;">面积：0-100m²（X轴刻度0-100）</div>
                    <div style="margin: 3px 0;">价格：0-500万元（Y轴刻度0-100，映射关系：价格/5）</div>
                    <div style="margin: 3px 0;">卧室：1-5间（Z轴刻度20-100，映射关系：卧室数×20）</div>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                    <div style="margin: 5px 0; color: #666;">
                        💡 <em>鼠标拖拽旋转视角，滚轮缩放</em>
                    </div>
                </div>
            `;
            
            // 添加图例到容器
            const container = document.getElementById('threeContainer');
            const legendDiv = document.createElement('div');
            legendDiv.innerHTML = legendHTML;
            container.style.position = 'relative';
            container.appendChild(legendDiv.firstElementChild);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function toggleDataPoints() {
            if (!dataPointsVisible) {
                show3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = '🙈 隐藏3D房价数据';
                document.getElementById('showDataBtn').style.background = '#6c757d';
                dataPointsVisible = true;
            } else {
                hide3DDataPoints();
                document.getElementById('showDataBtn').innerHTML = '👁️ 显示3D房价数据';
                document.getElementById('showDataBtn').style.background = '#dc3545';
                dataPointsVisible = false;
            }
        }
        
        function show3DDataPoints() {
            // 清除现有数据点
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // 添加新的数据点，使用新的坐标系
            houseData.forEach((house, index) => {
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x330000
                });
                const sphere = new THREE.Mesh(geometry, material);
                
                // 新的坐标映射（左下角为原点）：
                // X轴：面积（向右，0-100）
                // Y轴：价格（向上，0-100）
                // Z轴：卧室数（向内，0-100）
                sphere.position.set(
                    house.area,  // 面积直接映射到X轴
                    house.price / 5,  // 价格除以5映射到Y轴（0-500万映射到0-100）
                    house.rooms * 20  // 卧室数乘以20映射到Z轴（1-5间映射到20-100）
                );
                
                // 添加数据标签（简化显示）
                const label = createDataLabel(`${house.name}\n${house.area}m², ${house.price}万`);
                label.position.set(house.area + 3, house.price / 5, house.rooms * 20);
                scene.add(label);
                
                scene.add(sphere);
                scatterPoints.push(sphere);
            });
            
            // 将数据点分组命名，便于管理
            const dataGroup = new THREE.Group();
            dataGroup.name = 'dataPoints';
            scatterPoints.forEach(point => dataGroup.add(point));
            scene.add(dataGroup);
        }
        
        function createDataLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 40;
            
            // 绘制背景
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            context.fillRect(0, 0, 200, 40);
            context.strokeStyle = '#666';
            context.lineWidth = 1;
            context.strokeRect(0, 0, 200, 40);
            
            // 绘制文字
            context.font = 'bold 10px Arial';
            context.fillStyle = '#333';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            const lines = text.split('\n');
            lines.forEach((line, index) => {
                context.fillText(line, 100, 10 + index * 12);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 1.6, 1);
            
            return sprite;
        }
        
        function hide3DDataPoints() {
            // 清除数据点
            scatterPoints.forEach(point => scene.remove(point));
            scatterPoints = [];
            
            // 清除所有标签
            if (scene) {
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
        }
        
        function showRegressionPlane(coeffs) {
            if (!scene) return;
            
            // 移除旧的回归平面
            const oldPlane = scene.getObjectByName('regressionPlane');
            if (oldPlane) scene.remove(oldPlane);
            const oldEdges = scene.getObjectByName('regressionPlaneEdges');
            if (oldEdges) scene.remove(oldEdges);
            
            // 获取实际数据范围
            const areas = houseData.map(d => d.area);
            const rooms = houseData.map(d => d.rooms);
            const prices = houseData.map(d => d.price);
            
            const minArea = Math.min(...areas);
            const maxArea = Math.max(...areas);
            const minRooms = Math.min(...rooms);
            const maxRooms = Math.max(...rooms);
            
            // 创建回归平面 - 使用与数据点相同的坐标系映射
            const planeWidth = maxArea - minArea;
            const planeDepth = (maxRooms - minRooms) * 20;
            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeDepth, 20, 20);
            
            // 计算平面4个角点在3D坐标系中的Y坐标（价格）
            const cornerPrices = [
                (coeffs.a1 * minArea + coeffs.a2 * minRooms + coeffs.b) / 5,  // 映射到Y轴
                (coeffs.a1 * maxArea + coeffs.a2 * minRooms + coeffs.b) / 5,
                (coeffs.a1 * maxArea + coeffs.a2 * maxRooms + coeffs.b) / 5,
                (coeffs.a1 * minArea + coeffs.a2 * maxRooms + coeffs.b) / 5
            ];
            
            // 计算平均高度
            const avgPrice = (cornerPrices.reduce((a, b) => a + b, 0) / 4);
            
            // 创建平面材质
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.name = 'regressionPlane';
            
            // 设置平面位置 - 使用与数据点相同的坐标系
            plane.position.set(
                (minArea + maxArea) / 2,  // X轴：面积中心
                avgPrice,  // Y轴：平均价格（已映射）
                ((minRooms + maxRooms) / 2) * 20  // Z轴：卧室数中心（已映射）
            );
            
            // 根据回归系数计算正确的倾斜角度
            // 注意：在3D坐标系中，我们需要考虑映射关系
            const slopeX = coeffs.a1 / 5;  // 面积对价格的影响（已映射）
            const slopeZ = coeffs.a2 * 20 / 5;  // 卧室数对价格的影响（已映射）
            
            // 设置正确的旋转角度
            plane.rotation.x = -Math.atan(slopeZ); // Z轴方向的倾斜
            plane.rotation.z = Math.atan(slopeX); // X轴方向的倾斜
            
            scene.add(plane);
            
            // 添加边框
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x1976D2, 
                linewidth: 2 
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.position.copy(plane.position);
            edges.rotation.copy(plane.rotation);
            edges.name = 'regressionPlaneEdges';
            scene.add(edges);
            
            // 添加调试信息
            console.log('回归系数:', coeffs);
            console.log('数据范围:', {minArea, maxArea, minRooms, maxRooms});
            console.log('平面位置:', plane.position);
            console.log('平面旋转:', {x: plane.rotation.x, z: plane.rotation.z});
            
            // 验证回归模型
            console.log('=== 回归模型验证 ===');
            houseData.forEach((house, index) => {
                const predictedPrice = coeffs.a1 * house.area + coeffs.a2 * house.rooms + coeffs.b;
                const error = house.price - predictedPrice;
                console.log(`数据点${index + 1}: 实际${house.price}万, 预测${predictedPrice.toFixed(1)}万, 误差${error.toFixed(1)}万`);
            });
        }

        function calculateMultipleRegression() {
            // 二元线性回归计算（面积和卧室数）
            const n = houseData.length;
            
            // 计算均值
            const meanArea = houseData.reduce((sum, d) => sum + d.area, 0) / n;
            const meanRooms = houseData.reduce((sum, d) => sum + d.rooms, 0) / n;
            const meanPrice = houseData.reduce((sum, d) => sum + d.price, 0) / n;
            
            // 计算协方差和方差
            let covAreaPrice = 0, covRoomsPrice = 0, varArea = 0, varRooms = 0, covAreaRooms = 0;
            
            houseData.forEach(d => {
                covAreaPrice += (d.area - meanArea) * (d.price - meanPrice);
                covRoomsPrice += (d.rooms - meanRooms) * (d.price - meanPrice);
                varArea += (d.area - meanArea) ** 2;
                varRooms += (d.rooms - meanRooms) ** 2;
                covAreaRooms += (d.area - meanArea) * (d.rooms - meanRooms);
            });
            
            // 解二元线性方程组
            const denominator = varArea * varRooms - covAreaRooms ** 2;
            const a1 = (covAreaPrice * varRooms - covRoomsPrice * covAreaRooms) / denominator;
            const a2 = (covRoomsPrice * varArea - covAreaPrice * covAreaRooms) / denominator;
            const b = meanPrice - a1 * meanArea - a2 * meanRooms;
            
            return {a1, a2, b};
        }
        
        function calculateBestFitModel() {
            if (!dataPointsVisible) {
                alert('请先点击"显示房价数据"按钮！');
                return;
            }
            
            if (houseData.length < 3) {
                alert('需要至少3个数据点才能计算多元回归模型！');
                return;
            }
            
            document.getElementById('formulaDisplay').innerHTML = 
                '🧮 正在用多元线性回归计算最佳模型...';
            
            const coeffs = calculateMultipleRegression();
            
            // 直接显示3D回归平面（移除Chart.js依赖）
            setTimeout(() => {
                // 显示二元回归公式
                document.getElementById('formulaDisplay').innerHTML = 
                    `📊 二元线性回归结果：<br>房价 = ${coeffs.a1.toFixed(1)}×面积 + ${coeffs.a2.toFixed(1)}×卧室数 + ${coeffs.b.toFixed(1)}<br><br>🎯 这个模型综合考虑了面积和卧室数！`;
                
                // 显示特征重要性（二维）
                document.getElementById('importanceDetails').innerHTML = 
                    `<strong>🏆 特征重要性：</strong><br>
                    1. 面积：每增加1m²，房价+${coeffs.a1.toFixed(1)}万元<br>
                    2. 卧室数：每多1间，房价+${coeffs.a2.toFixed(1)}万元`;
                
                document.getElementById('modelAccuracy').innerHTML = 
                    `📈 3D模型展示：红色点=实际数据，蓝色平面=回归预测`;
                
                // 显示3D回归平面
                showRegressionPlane(coeffs);
                
                modelCalculated = true;
            }, 500);
        }


        
        function makePrediction() {
            if (!modelCalculated) {
                alert('请先点击"计算多元回归模型"按钮！');
                return;
            }
            
            const area = parseFloat(document.getElementById('predArea').value);
            const rooms = parseFloat(document.getElementById('predRooms').value);
            
            if (isNaN(area) || isNaN(rooms)) {
                alert('请输入面积和卧室数！');
                return;
            }
            
            // 使用二元回归系数进行预测
            const coeffs = calculateMultipleRegression();
            const predictedPrice = coeffs.a1 * area + coeffs.a2 * rooms + coeffs.b;
            
            // 在3D场景中显示预测点
            const predictionGeometry = new THREE.SphereGeometry(3, 16, 16);
            const predictionMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x003300
            });
            const predictionSphere = new THREE.Mesh(predictionGeometry, predictionMaterial);
            
            // 使用与数据点相同的坐标系映射
            predictionSphere.position.set(
                area,  // 面积
                predictedPrice / 5,  // 价格除以5（与数据点一致）
                rooms * 20  // 卧室数乘以20（与数据点一致）
            );
            
            // 添加预测点标签
            const predictionLabel = createDataLabel(`预测\n${area}m², ${predictedPrice.toFixed(1)}万`);
            predictionLabel.position.set(area + 3, predictedPrice / 5, rooms * 20);
            scene.add(predictionLabel);
            scene.add(predictionSphere);
            
            // 添加调试信息
            console.log('预测点位置:', predictionSphere.position);
            console.log('预测结果:', {area, rooms, predictedPrice});
            
            // 显示预测结果
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = 
                    `🎯 预测结果：这套房子的价格大约是${predictedPrice.toFixed(1)}万元`;
            }
        }

        function addData() {
            const area = parseFloat(document.getElementById('newArea').value);
            const rooms = parseFloat(document.getElementById('newRooms').value);
            const price = parseFloat(document.getElementById('newPrice').value);
            
            if (isNaN(area) || isNaN(rooms) || isNaN(price)) {
                alert('请输入有效的数字！');
                return;
            }
            
            houseData.push({area, rooms, price, name: '新房子'});
            
            // 更新表格
            const tbody = document.getElementById('dataTable');
            const row = tbody.insertRow();
            row.innerHTML = `<td>新房子</td><td>${area}</td><td>${rooms}</td><td>${price}</td>`;
            
            // 清除3D场景中的所有元素
            if (scene) {
                // 清除数据点
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // 清除回归平面
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // 清除回归平面边框
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // 清除所有标签（通过类型过滤）
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = '已添加新数据！请重新计算模型';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = '请输入房子特征进行预测';
            }
        }

        function resetData() {
            houseData = [
                {area: 80, rooms: 2, price: 200, name: '房子A'},
                {area: 100, rooms: 3, price: 280, name: '房子B'},
                {area: 120, rooms: 3, price: 350, name: '房子C'},
                {area: 90, rooms: 2, price: 220, name: '房子D'},
                {area: 150, rooms: 4, price: 450, name: '房子E'},
                {area: 70, rooms: 2, price: 180, name: '房子F'}
            ];
            
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = `
                <tr><td>房子A</td><td>80</td><td>2</td><td>200</td></tr>
                <tr><td>房子B</td><td>100</td><td>3</td><td>280</td></tr>
                <tr><td>房子C</td><td>120</td><td>3</td><td>350</td></tr>
                <tr><td>房子D</td><td>90</td><td>2</td><td>220</td></tr>
                <tr><td>房子E</td><td>150</td><td>4</td><td>450</td></tr>
                <tr><td>房子F</td><td>70</td><td>2</td><td>180</td></tr>
            `;
            
            // 清除3D场景中的所有元素
            if (scene) {
                // 清除数据点
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // 清除回归平面
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // 清除回归平面边框
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // 清除所有标签（通过类型过滤）
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            dataPointsVisible = false;
            modelCalculated = false;
            
            document.getElementById('showDataBtn').innerHTML = '👁️ 显示3D房价数据';
            document.getElementById('showDataBtn').style.background = '#dc3545';
            document.getElementById('formulaDisplay').innerHTML = '正在计算中...';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = '请输入面积和卧室数进行预测';
            }
            document.getElementById('importanceDetails').innerHTML = '点击"计算多元回归模型"查看特征权重';
            document.getElementById('modelAccuracy').innerHTML = '';
        }

        function generateRandomData() {
            houseData = [];
            const names = ['房子G', '房子H', '房子I', '房子J', '房子K', '房子L'];
            
            for (let i = 0; i < 6; i++) {
                const area = Math.floor(Math.random() * 100) + 60; // 60-160
                const rooms = Math.floor(Math.random() * 3) + 2; // 2-4
                const price = Math.floor(area * 2.5 + rooms * 30 + Math.random() * 50 + 50);
                
                houseData.push({area, rooms, price, name: names[i]});
            }
            
            // 更新表格
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            houseData.forEach(house => {
                const row = tbody.insertRow();
                row.innerHTML = `<td>${house.name}</td><td>${house.area}</td><td>${house.rooms}</td><td>${house.price}</td>`;
            });
            
            // 清除3D场景中的所有元素
            if (scene) {
                // 清除数据点
                const dataPoints = scene.getObjectByName('dataPoints');
                if (dataPoints) scene.remove(dataPoints);
                
                // 清除回归平面
                const regressionPlane = scene.getObjectByName('regressionPlane');
                if (regressionPlane) scene.remove(regressionPlane);
                
                // 清除回归平面边框
                const regressionPlaneEdges = scene.getObjectByName('regressionPlaneEdges');
                if (regressionPlaneEdges) scene.remove(regressionPlaneEdges);
                
                // 清除所有标签（通过类型过滤）
                const labels = scene.children.filter(obj => obj.type === 'Sprite');
                labels.forEach(label => scene.remove(label));
            }
            
            if (dataPointsVisible) {
                show3DDataPoints();
            }
            
            modelCalculated = false;
            document.getElementById('formulaDisplay').innerHTML = '已生成随机数据！请重新计算模型';
            const predictionDiv = document.getElementById('predictionResult');
            if (predictionDiv) {
                predictionDiv.innerHTML = '请输入面积和卧室数进行预测';
            }
        }

        function showRegressionPlane(coeffs) {
            if (!scene) return;
            
            // 移除旧的回归平面
            const oldPlane = scene.getObjectByName('regressionPlane');
            if (oldPlane) scene.remove(oldPlane);
            const oldEdges = scene.getObjectByName('regressionPlaneEdges');
            if (oldEdges) scene.remove(oldEdges);
            
            // 获取实际数据范围
            const areas = houseData.map(d => d.area);
            const rooms = houseData.map(d => d.rooms);
            const prices = houseData.map(d => d.price);
            
            const minArea = Math.min(...areas) - 10;
            const maxArea = Math.max(...areas) + 10;
            const minRooms = Math.min(...rooms) - 0.5;
            const maxRooms = Math.max(...rooms) + 0.5;
            const minPrice = Math.min(...prices) - 20;
            const maxPrice = Math.max(...prices) + 20;
            
            // 重新映射坐标系：
            // X轴：面积（左右方向）
            // Y轴：价格（上下方向）  
            // Z轴：卧室数（前后方向）
            
            // 计算实际数据在3D空间中的中心点
            const centerX = (minArea + maxArea) / 2 - 100; // 减去100是之前的偏移
            const centerY = (minPrice + maxPrice) / 2 - 300; // 减去300是之前的偏移
            const centerZ = ((minRooms + maxRooms) / 2) * 20 - 60; // 乘以20是之前的缩放
            
            // 创建足够大的平面 - 使用实际3D坐标系中的尺寸
            const planeWidth = maxArea - minArea;  // X轴方向的宽度
            const planeDepth = (maxRooms - minRooms) * 20;  // Z轴方向的深度（考虑缩放因子）
            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeDepth, 20, 20);
            
            // 计算平面4个角点的实际价格
            const cornerPrices = [
                coeffs.a1 * minArea + coeffs.a2 * minRooms + coeffs.b,
                coeffs.a1 * maxArea + coeffs.a2 * minRooms + coeffs.b,
                coeffs.a1 * maxArea + coeffs.a2 * maxRooms + coeffs.b,
                coeffs.a1 * minArea + coeffs.a2 * maxRooms + coeffs.b
            ];
            
            // 计算平均高度
            const avgPrice = (cornerPrices.reduce((a, b) => a + b, 0) / 4);
            
            // 创建平面材质
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x2196F3,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.name = 'regressionPlane';
            
            // 设置平面位置 - 使用与数据点相同的坐标系
            plane.position.set(
                (minArea + maxArea) / 2 - 100,
                avgPrice - 300,
                ((minRooms + maxRooms) / 2) * 20 - 60
            );
            
            // 根据回归系数计算正确的倾斜角度
            // 计算平面的法向量方向
            const slopeX = coeffs.a1; // 面积系数
            const slopeZ = coeffs.a2; // 卧室系数
            
            // 设置正确的旋转角度
            plane.rotation.x = -Math.atan(slopeZ / 20); // Z轴方向的倾斜
            plane.rotation.z = Math.atan(slopeX); // X轴方向的倾斜
            
            scene.add(plane);
            
            // 添加边框
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x1976D2, 
                linewidth: 3 
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.position.copy(plane.position);
            edges.rotation.copy(plane.rotation);
            edges.name = 'regressionPlaneEdges';
            scene.add(edges);
            
            // 添加坐标轴标签
            updateAxisLabels(minArea, maxArea, minRooms, maxRooms, minPrice, maxPrice);
        }
        
        function updateAxisLabels(minArea, maxArea, minRooms, maxRooms, minPrice, maxPrice) {
            // 更新或创建坐标轴标签
            const existingLabels = scene.children.filter(obj => obj.name && obj.name.includes('axisLabel'));
            existingLabels.forEach(label => scene.remove(label));
            
            // 创建新的坐标轴标签
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(30, 7.5, 1);
                
                return sprite;
            }
            
            // X轴标签
            const xLabel = createTextSprite(`面积 (${minArea}-${maxArea}m²)`);
            xLabel.position.set(maxArea - 100 + 20, -10, 0);
            xLabel.name = 'axisLabelX';
            scene.add(xLabel);
            
            // Y轴标签
            const yLabel = createTextSprite(`价格 (${minPrice}-${maxPrice}万元)`);
            yLabel.position.set(0, maxPrice - 300 + 20, 0);
            yLabel.name = 'axisLabelY';
            scene.add(yLabel);
            
            // Z轴标签
            const zLabel = createTextSprite(`卧室数 (${minRooms}-${maxRooms}间)`);
            zLabel.position.set(0, -10, maxRooms * 20 - 60 + 20);
            zLabel.name = 'axisLabelZ';
            scene.add(zLabel);
        }

        // 测试回归模型
        function testRegressionModel() {
            console.log('=== 测试回归模型 ===');
            const coeffs = calculateMultipleRegression();
            console.log('回归系数:', coeffs);
            
            // 测试几个数据点
            const testPoints = [
                {area: 80, rooms: 2, price: 200},
                {area: 100, rooms: 3, price: 280},
                {area: 120, rooms: 3, price: 350}
            ];
            
            testPoints.forEach((point, index) => {
                const predictedPrice = coeffs.a1 * point.area + coeffs.a2 * point.rooms + coeffs.b;
                console.log(`测试点${index + 1}: 面积${point.area}m², 卧室${point.rooms}间, 实际价格${point.price}万, 预测价格${predictedPrice.toFixed(1)}万`);
            });
        }
        
        // 初始化
        window.onload = function() {
            init3DScene();
            // 延迟执行测试
            setTimeout(testRegressionModel, 1000);
        };
    </script>
</body>
</html>